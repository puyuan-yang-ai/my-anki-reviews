好的，我先来回答你的三个问题，然后重新梳理需求。

---

## 回答你的问题

### 问题1：接口无状态，对话计划如何持久化？

你提出了一个非常关键的问题！**无状态接口 + 需要持久化计划** 的矛盾，有以下几种常见解决方案：

| 方案 | 做法 | 优点 | 缺点 |
|------|------|------|------|
| **方案A：前端透传** | 首次调用返回 `plan`，前端每次请求都带上 | 简单，后端完全无状态 | 请求体变大；plan 暴露给前端 |
| **方案B：后端缓存** | 用 Redis/内存缓存，key 是 `session_id` | 后端控制，plan 不暴露 | 需要引入缓存依赖；需要处理过期 |
| **方案C：每次重新生成** | 不存 plan，每次根据 history 动态决定下一步 | 最简单，完全无状态 | 策略可能不连贯；LLM 成本高 |

**我的建议是：方案A（前端透传）**

理由：
1. 你的系统已经在透传 `history`（对话历史），再透传一个 `plan` 是同样的模式
2. 保持后端完全无状态，符合你现有的架构风格
3. `plan` 本质上是给 AI 的参考信息，不是敏感数据，暴露给前端问题不大

具体做法：
```python
# 首次调用返回
{
    "ai_message": "你好！让我们来聊聊...",
    "conversation_plan": {...},  # 新增字段，首次返回
    "is_finished": false
}

# 后续调用时，前端把 plan 带回来
{
    "user_profile": {...},
    "history": [...],
    "user_message": "...",
    "conversation_plan": {...}  # 前端透传回来
}
```

---

### 问题2：哪些模块需要额外存储？

你的理解是正确的！让我确认一下：

| 模块 | 输入来源 | 是否需要额外存储 |
|------|----------|------------------|
| 对话计划生成 | `user_profile` | ✅ 需要（生成一次，后续复用） |
| 对话策略 | `history` + `user_message` + `plan` | ❌ 不需要（每次实时计算） |
| 对话执行 | 策略输出 | ❌ 不需要（每次实时生成） |
| 意图识别 | AI 回复内容 | ❌ 不需要（每次实时判断） |
| 结束判断 | AI 回复内容 | ❌ 不需要（每次实时判断） |

**结论**：确实只有**对话计划**需要持久化，其他模块都是基于当前请求的输入实时计算的。

---

### 问题3：virturlInterview 的 interview_plan 设计是否有问题？

**你说得对，这确实是一个设计问题！**

让我看一下 `virturlInterview` 的实际情况：

```python
# interview_process_router.py
interview = CallInterview(interview_id)  # 每次请求都创建新实例
```

```python
# virtual_interview.py
class CallInterview:
    def __init__(self, interview_id):
        self.interview_plan = None  # 实例变量，不会跨请求保留
```

**问题分析**：
- 每次 HTTP 请求都会创建一个新的 `CallInterview` 实例
- `self.interview_plan` 在首次调用时生成，但请求结束后实例被销毁
- 下一次请求又是新实例，`interview_plan` 又是 `None`

**这确实是一个 bug！** 后续对话根本没有用到首次生成的面试计划。

不过看代码，它好像有个"补救措施"：

```326:346:e:/Python Code/cv-project/project_code/career/code/service/virtual_interview.py
        try:
            # 准备面试计划信息
            plan_info = ""
            if self.interview_plan:
                remaining_questions = self.interview_plan['questions'][self.current_question_index:]
                # ...
```

由于 `self.interview_plan` 在非首次调用时是 `None`，所以 `plan_info` 会是空字符串，面试计划实际上**没有被使用**。它走的是纯 LLM 策略生成的方式。

**所以你的深度简历对话接口，不要重复这个设计错误**，应该采用前端透传方案。

---

## 重新梳理需求

### 核心目标

**深度简历优化 - 对话接口 (converse)** 是一个面向**只有基础信息、没有完整简历的学生**的信息挖掘服务。通过多轮对话，以**长辈/职业培训师**的温和鼓励语气，挖掘学生的个人优点和潜力，收集足够的素材后，由前端调用 `generate` 接口生成简历。

### 接口设计

**路由**：`POST /resume/deep-optimization/converse`

**请求体**：
```python
class DeepConverseRequest(BaseModel):
    user_profile: UserProfile           # 用户基本档案
    history: List[ChatMessage]          # 对话历史
    user_message: str                   # 用户本轮回复
    conversation_plan: Optional[dict]   # 对话计划（首次为空，后续透传）
```

**响应**（流式 SSE）：
```json
{"type": "chunk", "content": "你好..."}
{"type": "chunk", "content": "让我们..."}
{"type": "DONE", "content": "[DONE]"}
{"type": "plan", "content": {...}}       // 仅首次返回
{"type": "over", "content": "over"}      // 对话结束时返回
```

### 5大模块流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                    converse 接口处理流程                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 预处理：沉默检测                                              │    │
│  │ - 检查最近3轮 user_message 是否有效                           │    │
│  │ - 若连续3次无效 → 返回结束消息 + over                          │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 模块1：对话计划生成（仅首次）                                   │    │
│  │ - 输入：user_profile                                          │    │
│  │ - 输出：conversation_plan（问题清单、挖掘维度）                 │    │
│  │ - 返回开场白 + plan                                           │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 模块2：对话策略模块                                            │    │
│  │ - 输入：history + user_message + conversation_plan            │    │
│  │ - 输出：下一步策略（追问/换话题/案例分析/准备结束）              │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 模块3：对话执行模块                                            │    │
│  │ - 输入：策略 + history                                         │    │
│  │ - 输出：具体的 AI 回复（流式返回）                              │    │
│  │ - 语气：温和鼓励型                                             │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 模块4：意图/状态识别模块                                        │    │
│  │ - 输入：AI 回复内容 + 最近对话                                  │    │
│  │ - 输出：当前动作类型（新问题/追问/案例分析/确认状态）            │    │
│  │ - 用途：记录进度，调整后续策略参考                              │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 模块5：结束判断模块                                            │    │
│  │ - 输入：AI 回复内容                                            │    │
│  │ - 判断 AI 是否表达了"对话结束"的意图                           │    │
│  │ - 若是 → 返回 {"type": "over"}                                │    │
│  │ - 前端匹配到 "over" 后，可调用 generate 接口                   │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 对话内容规划（conversation_plan 示例）

```json
{
  "stages": [
    {
      "stage": "开场破冰",
      "goal": "建立信任，了解基本情况",
      "sample_questions": ["请简单介绍一下自己吧"]
    },
    {
      "stage": "专业探索",
      "goal": "挖掘专业相关的技能和收获",
      "sample_questions": ["你对所学的专业有什么看法？", "有没有哪门课让你印象特别深刻？"]
    },
    {
      "stage": "经历挖掘",
      "goal": "发现项目/实习/社团等经历中的亮点",
      "sample_questions": ["有没有做过什么让你特别骄傲的事情？"]
    },
    {
      "stage": "案例分析",
      "goal": "通过场景判断思维模式",
      "sample_questions": ["假设你遇到XX情况，你会怎么处理？"]
    },
    {
      "stage": "职业规划",
      "goal": "了解未来方向，收集求职意向",
      "sample_questions": ["毕业后你想做什么工作？", "除了本专业，还关注过其他方向吗？"]
    },
    {
      "stage": "收尾总结",
      "goal": "确认信息完整，友好结束",
      "sample_questions": ["还有什么想补充的吗？"]
    }
  ]
}
```

### 关键行为确认

| 项目 | 行为 |
|------|------|
| 响应方式 | 流式 SSE（同 virturlInterview） |
| 对话计划持久化 | 前端透传（首次返回，后续带回） |
| 沉默检测 | 连续 3 次无效回复 → 强制结束 |
| 对话轮次限制 | 暂无限制 |
| 案例分析 | 需要，给出场景让学生分析 |
| 结束触发 | AI 自动判断，返回 over 信号 |
| AI 语气 | 温和鼓励型（长辈/职业培训师） |

---

## 我的剩余疑问

1. **plan 透传的数据结构**：`conversation_plan` 返回给前端后，前端是原样透传回来，还是会有修改？（我假设是原样透传）

2. **流式响应中 plan 的位置**：`plan` 是在流式响应最后作为单独的 SSE 事件返回，还是放在某个字段里？我倾向于这样：
   ```
   {"type": "chunk", "content": "..."}
   {"type": "DONE", "content": "[DONE]"}
   {"type": "plan", "content": {...}}   // 仅首次
   ```

3. **意图识别模块的必要性**：在 virturlInterview 中，意图识别用于更新 `current_question_index`。但如果我们不限制轮次，且 plan 是参考而非严格执行，意图识别模块是否可以简化或省略？

---

确认以上内容后，我们就可以开始编写代码了！
