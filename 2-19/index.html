
<html>
<head>
<meta charset="UTF-8">
<title>Export Notes by xxhk.org</title>
<style>

body { font-family: Arial, sans-serif; }
.card { border: 2px solid #000; padding: 10px; border-radius: 10px; margin-bottom: 20px; }
img {
max-width: 100%;
height: auto;
border: 1px solid lightgray;
border-radius: 10px;
display: inline-block;
margin: 10px 0px;
}
.separator { border-top: 1px dashed #000; margin: 10px 0; }
.tags { background-color: lightgray; padding: 5px 10px; margin-bottom: 10px; border-radius: 5px; display: inline-block; }
.footer {
text-align: center;
color: grey;
margin-top: 20px;
padding: 10px;
}

.video-container {
margin: 10px 0;
}
.video-placeholder {
position: relative;
cursor: pointer;
}
.play-button {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 68px;
height: 48px;
background-color: rgba(0, 0, 0, 0.7);
border-radius: 14px;
cursor: pointer;
}
.play-button::before {
content: '';
position: absolute;
top: 50%;
left: 55%;
transform: translate(-50%, -50%);
border-style: solid;
border-width: 12px 0 12px 20px;
border-color: transparent transparent transparent white;
}
.play-button:hover {
background-color: red;
}

</style>

</head>
<body>
<div id="cards-container">
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAG里面，增强模块的目的是什么？【通过调整什么来提升什么？】</div>
<div class="separator"></div>
<div class="field_1">通过调整或改进生成模型的输入来提升生成效果。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAG系统的工作流程里面，知识检索模块流程和步骤是什么？&nbsp; 【对PDF文本怎么处理？然后使用什么来对文本进行嵌入，导入到哪里，混合检索方式是什么？】</div>
<div class="separator"></div>
<div class="field_1">首先，我们通过处理大量的PDF文本构建本地知识库。在这个过程中，我们需要对PDF进行结构化处理，将文本切分成合适的块（chunk），确保每个块包含足够的上下文信息。<br>接着，我们使用embedding模型对这些文本块进行嵌入，并将其导入到一个高效的向量数据库，如Milvus。<br>在检索阶段，我们采用BM25和embedding检索的混合方式，利用BM25进行初步的关键词匹配，然后使用embedding模型计算语义相似度，最终返回最相关的上下文信息。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs 它通过什么化的指标，来对哪两个模块进行独立的评估？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">它通过一套<b><span style="color: rgb(255, 0, 127);">结构化</span></b>的指标，对RAG系统的<span style="color: rgb(255, 0, 127);"><b>检索</b></span>和<span style="color: rgb(255, 0, 127);"><b>生成</b></span>模块进行独立和整体评估，帮助开发者优化系统性能并确保其可靠性。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">在RAG系统中，检索模块和生成模块分别的作用是什么？负责什么？&nbsp;<br>【检索模块是从哪里提取什么，生成模块是利用什么生成什么？】</div>
<div class="separator"></div>
<div class="field_1"><span style="background-color: oklch(0.99 0.004 106.471);"><span style="color: oklch(0.304 0.04 213.681);">检索模块负责</span><span style="color: rgb(255, 0, 127);"><b>从外部知识库中提取相关信息</b></span><span style="color: oklch(0.304 0.04 213.681);">，<br>而生成模块</span><b><span style="color: rgb(255, 0, 127);">利用这些信息生成最终的回答。</span></b></span></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs框架 提供端到端的评估。 是什么意思？&nbsp; 【评估整个什么？包括从哪里到哪里的流程？】</div>
<div class="separator"></div>
<div class="field_1">综合评估整个RAG管道，包括从检索到生成的完整流程。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs需要以下四类数据作为输入 分别是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li><div><strong>Question（用户查询）</strong>：用户提出的问题，作为RAG管道的输入。</div></li><li><div><strong>Contexts（检索上下文）</strong>：从知识库中检索到的相关文本片段，用于支持回答生成。</div></li><li><div><strong>Answer（生成答案）</strong>：基于上下文和查询生成的回答。</div></li><li><div><strong>Ground Truth（参考答案）</strong>：问题的真实答案，仅在某些指标（如上下文召回率）计算时需要。</div></li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs需要以下四类数据作为输入 ，其中question指的是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><div>Question（用户查询）：用户提出的问题，作为RAG管道的输入。</div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs 里面，检索模块指标，其中，上下文召回率（Context Recall） 是什么意思？<br>【衡量什么信息中包含多少与什么相关的信息？】</div>
<div class="separator"></div>
<div class="field_1"><div>衡量检索到的信息中包含多少与参考答案相关的信息。</div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs 里面，生成模块指标,包括哪两个？ 中文英文以及相关的含义是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li><div><strong>忠实性（Faithfulness）</strong>：评估生成答案是否与检索到的信息一致，避免“幻觉”现象，answer 和 context。</div></li><li><div><strong>答案相关性（Answer Relevancy）</strong>：衡量生成答案是否直接回应了用户查询，answer 和 question。</div><br><img src="images/paste-1923263f150de69ec0c1d2ed14a510e67bd1b1d6.jpg"></li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs 里面，生成模块指标,其中，忠实性（Faithfulness）表示什么意思？&nbsp; 【评估什么跟什么是否一致，避免什么现象？】</div>
<div class="separator"></div>
<div class="field_1"><div>评估生成答案是否与检索到的信息一致，避免“幻觉”现象。</div><br><img src="images/paste-1923263f150de69ec0c1d2ed14a510e67bd1b1d6.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs 里面，生成模块指标,其中，答案相关性（Answer Relevancy）表示什么意思？&nbsp; 【来衡量什么是否回应什么？】</div>
<div class="separator"></div>
<div class="field_1">衡量生成答案是否直接回应了用户查询。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs 里面，端到端的指标里面，答案正确性（Answer Correctness）是什么意思？&nbsp; 【衡量什么跟什么是否一致？】</div>
<div class="separator"></div>
<div class="field_1">输出答案和标准答案。衡量生成答案是否与参考答案一致。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs 里面，忠实性通过什么或者什么来评估什么是否基于什么。&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><div>忠实性通过<span style="color: rgb(255, 0, 127);"><b>语义相似度或人工标注</b></span>来评估<span style="color: rgb(255, 0, 127);"><b>生成答案answer</b></span>是否基于<span style="color: rgb(255, 0, 127);"><b>检索内容context。</b></span></div><div><br><img src="images/paste-1923263f150de69ec0c1d2ed14a510e67bd1b1d6.jpg"><span style="color: rgb(255, 0, 127);"><b><br></b></span></div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">检索增强生成（Retrieval-Augmented Generation, RAG）是一种 结合什么和什么的框架？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">结合<span style="color: rgb(255, 0, 127);"><b>信息检索</b></span>和<span style="color: rgb(255, 0, 127);"><b>生成技术</b></span>的框架。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">语义切割是什么意思？&nbsp; 【基于什么来进行分割？】</div>
<div class="separator"></div>
<div class="field_1">基于句子、段落或主题等语义单元进行分割。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">递归切割是什么意思以及它适合什么样的 文本。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">通过递归方式逐步缩小块大小，直到满足预定条件。这种方法适用于处理<b><span style="color: rgb(255, 0, 127);">复杂结构化</span></b>文档，例如<span style="color: rgb(255, 0, 127);"><b>Markdown或LaTeX</b></span>格式。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0"><span style="color: oklch(0.304 0.04 213.681); background-color: oklch(0.99 0.004 106.471);">嵌入模型可根据任务需求选择。</span><span style="color: oklch(0.304 0.04 213.681); background-color: oklch(0.99 0.004 106.471);">BERT 以及&nbsp;</span><span style="color: oklch(0.304 0.04 213.681); background-color: oklch(0.99 0.004 106.471);">E5或bge-large，这两者分别适合什么？&nbsp;</span><br>【前者适合什么语义表示？后者适合什么任务？】</div>
<div class="separator"></div>
<div class="field_1"><span style="color: oklch(0.304 0.04 213.681); background-color: oklch(0.99 0.004 106.471);">BERT适合短文本语义表示，而E5或bge-large等优化模型适合搜索任务。</span></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0"><font color="oklch(0.304 0.04 213.681)"><span style="background-color: oklch(0.99 0.004 106.471);">对于向量数据库来说，用户的查询会变成什么，并与谁进行什么样的比较？用到了什么数学算法？&nbsp;</span></font></div>
<div class="separator"></div>
<div class="field_1"><div>用户查询也被<span style="color: rgb(255, 0, 127);"><b>嵌入为向量</b></span>，并与<span style="color: rgb(255, 0, 127);"><b>数据库</b></span>中的<span style="color: rgb(255, 0, 127);"><b>向量</b></span>进行<span style="color: rgb(255, 0, 127);"><b>相似度匹配</b></span>（如<b><span style="color: rgb(255, 0, 127);">余弦相似度</span></b>）。</div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">BM25 为什么可以用于传统的搜索引擎，<br>混合检索为什么可以用于问答系统？</div>
<div class="separator"></div>
<div class="field_1">BM25 使用的是关键词精确匹配，<br>混合检索 使用了语义理解。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">BM25 这个算法通过什么方式来进行排名？</div>
<div class="separator"></div>
<div class="field_1">是通过匹配的关键词，他们的频率和权重来进行排名。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">用一张图来描述RAGAs里面的6个评价指标。&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><br><img src="images/paste-1923263f150de69ec0c1d2ed14a510e67bd1b1d6.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs里面评估  检索模块用到哪两个指标，以及每个指标跟哪两个部分相关？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>上下文召回率，Context 和 Ground Truth ,</li><li>上下文精确度，Context 和 Question。&nbsp;</li><li><br><img src="images/paste-1923263f150de69ec0c1d2ed14a510e67bd1b1d6.jpg"><br></li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-15 导入Edge::2-19</div>
<div class="field_0">RAGAs里面评估 生成模块用到哪两个指标，以及每个指标跟哪两个部分相关？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">答案相关性，Answer 和 Question，<br>忠实度，Answer 和 Context。&nbsp;<br><br><img src="images/paste-1923263f150de69ec0c1d2ed14a510e67bd1b1d6.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAGAs 里面，忠实性 通过哪两种方式来进行评估？</div>
<div class="separator"></div>
<div class="field_1">语义相似度或者人工标注。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">大模型的混合检索指的是是将什么和什么结合起来使用。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">将传统的<span style="color: rgb(255, 0, 127);"><b>文本</b></span>检索（如基于<span style="color: rgb(255, 0, 127);"><b>关键词的检索</b></span>）和基于<b><span style="color: rgb(255, 0, 127);">语义向量</span></b>的检索（如通过<span style="color: rgb(255, 0, 127);"><b>向量数据库检索相似文本</b></span>）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">文本检索是基于什么词？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">关键词。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">混合检索 同时利用基于什么的匹配和基于什么的匹配，从而增强检索结果的全面性和准确性。</div>
<div class="separator"></div>
<div class="field_1">基于<span style="color: rgb(255, 0, 127);"><b>词汇</b></span>的匹配和基于<b><span style="color: rgb(255, 0, 127);">语义</span></b>的匹配。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG（Retrieval-Augmented Generation）系统中，混合检索会先使用什么来检索来做什么，再使用什么检索来做什么事情。&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">首先使用<span style="color: rgb(255, 0, 127);"><b>文本</b></span>检索（例如关键词匹配）获取<span style="color: rgb(255, 0, 127);"><b>相关文档</b></span>，<br>然后再使用<span style="color: rgb(255, 0, 127);"><b>语义向量</b></span>检索对这些文档进行<b><span style="color: rgb(255, 0, 127);">排序</span></b>，确保最终得到的候选文档在语义上最相关。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Graph-RAG"可以用来描述什么样的系统架构？&nbsp; 【什么和什么结合的架构？】</div>
<div class="separator"></div>
<div class="field_1">结合<span style="color: rgb(255, 0, 127);"><b>知识图谱</b></span>和<b><span style="color: rgb(255, 0, 127);">RAG</span></b>（Retrieval-Augmented Generation）系统的架构。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Graph-RAG" 这样的系统结构。 分别使用什么数据库以及存储什么样的知识。&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">图数据库（例如<span style="color: rgb(255, 0, 127);"><b>Neo4j</b></span>）作为<span style="color: rgb(255, 0, 127);"><b>结构化</b></span>知识存储来源，<br>而非结构化知识（如<span style="color: rgb(255, 0, 127);"><b>文本</b></span>数据）则存储在<b><span style="color: rgb(255, 0, 127);">向量数据库</span></b>中。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Graph-RAG 这个系统的三部分流程是什么？&nbsp;&nbsp; 【是哪两个数据库分别存储什么信息？然后两路召回的结果怎么样？然后最终输入给谁？】</div>
<div class="separator"></div>
<div class="field_1"><ol><li>通过Neo4j存储<span style="color: rgb(255, 0, 127);"><b>结构化知识</b></span>，<br>通过milvus向量数据库存储<b><span style="color: rgb(255, 0, 127);">非结构化知识</span></b>，<br></li><li>双路召回结果<span style="color: rgb(255, 0, 127);"><b>融合</b></span>后再与<b><span style="color: rgb(255, 0, 127);">Prompt拼接</span></b>，<br></li><li>最终交由<b><span style="color: rgb(255, 0, 127);">大模型生成</span></b>答案</li></ol></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 是将什么和什么结合起来的技术框架，通过检索什么来增强模型的什么能力？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><div>RAG是一种将<span style="color: rgb(255, 0, 127);"><b>检索系统</b></span>与<span style="color: rgb(255, 0, 127);"><b>生成模型</b></span>相结合的技术框架，通过检索<span style="color: rgb(255, 0, 127);"><b>外部知识</b></span>来增强语言模型的<b><span style="color: rgb(255, 0, 127);">生成</span></b>能力，提高回答的准确性和可靠性。</div><div><br></div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 三大的核心模块和机制是什么？&nbsp;【两个模块，一个机制分别是什么？】</div>
<div class="separator"></div>
<div class="field_1">检索模块，融合机制，生成模块。<br><ul><li><strong>检索模块</strong>：从知识库中检索相关文档，</li><li><strong>生成模块</strong>：基于检索内容和查询生成回答，</li><li><strong>融合机制</strong>：将检索到的信息与模型知识结合。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 三大的核心模块和机制，其中，检索模块是什么作用？【从哪里检索出什么？】</div>
<div class="separator"></div>
<div class="field_1">从知识库中检索相关文档。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 三大的核心模块和机制，其中，生成模块是什么作用？ 【基于什么和什么来生成什么？】</div>
<div class="separator"></div>
<div class="field_1">基于检索内容context和查询query生成回答</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统构建时候的，知识库构建，这个阶段包括哪些内容？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">1 对文档清洗以后进行分块得到chunks。<br>2 从chunks得到metadata元数据。<br>3 chunks经过嵌入模型以后得到嵌入向量embedding。<br>4 Chunks metadata embedding 3者共同建立索引系统</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统构建时候的，检索过程，这个阶段包括哪些内容？&nbsp;【查询什么化，计算什么，然后获取什么作为上下文？】</div>
<div class="separator"></div>
<div class="field_1"><ul><li>查询向量化</li><li>相似度计算</li><li>获取相关文档作为上下文</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统构建时候的，<strong>生成过程</strong>，这个阶段包括哪些内容？&nbsp;<br>【将什么和什么拼接到哪里形成什么输入到模型里面？】</div>
<div class="separator"></div>
<div class="field_1">用户query 和检索到的 context拼接到模板template里面形成Prompt输入到模型里面。<br><br><ul><li>上下文组装</li><li>提示词工程</li><li>答案生成</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统 他的技术优势是什么？&nbsp;<br>【为什么可以减少幻觉问题以及为什么实时性较强？】</div>
<div class="separator"></div>
<div class="field_1">减少幻觉是因为他基于最新的知识，<br>实时性较强，是因为它的数据库可以更新。<br><br>从两方面说，一方面是<span style="color: rgb(255, 0, 127);"><b>准确性</b></span>，另一方面是<b><span style="color: rgb(255, 0, 127);">灵活性</span></b>。<br><ul><li>准确性则是基于最新知识，并且可以减少幻觉问题，</li><li>灵活性则是知识库可以进行更新，而且实时性比较强。&nbsp;&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">构建RAG系统时 需要进行模型选型，哪三个模型的选型？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><strong>嵌入模型</strong>、<strong>排序模型</strong>和<strong>生成模型。</strong></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">FP16是什么的缩写以及 它指的是什么意思？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">“16-bit Floating Point”的缩写，指的是使用16位来表示浮点数。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在混合精度训练中，使用FP32的缩放因子与FP16数据进行计算操作时，最终的结果通常是什么数据格式？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">通常还是16位浮点数（FP16）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在混合精度训练中，缩放机制。<br>其中混合精度训练，混合的是哪两种精度，以及缩放机制针对的是哪个数据类型？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">混合的是 FP16 和 FP32，<br>缩放机制针对的是 FP16 。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 里面的融合机制是将什么跟什么进行融合？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">检索到的外部知识（context）与用户的查询（query）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0"><div>在RAG流程中，在检索模块里面包含这些内容，</div><div>1 查询向量化，</div><div>2 相似度计算</div><div>3 以及获取相关文档，</div><div>分别展开是什么意思？&nbsp;<br></div></div>
<div class="separator"></div>
<div class="field_1"><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(31, 35, 40);">当用户提出问题时，系统会先将这个</span><span style="color: rgb(255, 0, 127);"><b>问题转换成向量形式</b></span><span style="color: rgb(31, 35, 40);">，<br>然后用的是</span><b><span style="color: rgb(255, 0, 127);">向量相似度搜索</span></b><span style="color: rgb(31, 35, 40);">，<br></span></span><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(31, 35, 40);">在向量数据库中检索</span><b><span style="color: rgb(255, 0, 127);">相关</span></b><span style="color: rgb(31, 35, 40);">的文档片段，</span></span><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(31, 35, 40);">通常会返回</span><b><span style="color: rgb(255, 0, 127);">多个最相关</span></b><span style="color: rgb(31, 35, 40);">的文档片段。<br></span></span><img src="images/paste-41b069b0b2e78a74b7b0e38774f3780ef36ea7a2.jpg"></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0"><div>在RAG流程中，从用户的输入查询到最终的提示词生成。经历了五个阶段分别是什么？&nbsp;</div></div>
<div class="separator"></div>
<div class="field_1"><pre><code>→ 查询向量化
→ 向量相似度检索
→ 文档重排序
→ 上下文筛选和截断
→ 提示词构建和融合 </code></pre><pre><code><img src="images/paste-41b069b0b2e78a74b7b0e38774f3780ef36ea7a2.jpg"><br></code></pre></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Function Call 可以让模型在什么过程中，自动检测用户的什么？然后生成一个什么格式的什么请求？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">Function Call&nbsp;能让大模型在<span style="color: rgb(255, 0, 127);"><b>对话过程</b></span>中自动检测用户<span style="color: rgb(255, 0, 127);"><b>需求</b></span>，并以结构化的形式生成一个<b><span style="color: rgb(255, 0, 127);">函数调用</span></b>请求（通常为 <span style="color: rgb(255, 0, 127);"><b>JSON </b></span>格式），</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在 Function Call 机制下，大模型会根据什么来生成一个结构化的什么格式？ 包含了哪些内容？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">大模型会根据<span style="color: rgb(255, 0, 127);"><b>预设的函数描述</b></span>，自动生成一个包含“<span style="color: rgb(255, 0, 127);"><b>函数名称</b></span>”和<span style="color: rgb(255, 0, 127);"><b>“参数</b></span>”的结构化 <b><span style="color: rgb(255, 0, 127);">JSON 对象</span></b>，而不是直接返回纯文本回复。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在 Function Call 机制下，大模型是否会返回纯文本回复。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">不会。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在 Function Call 机制下，大模型会返回函数名称和对应参数，随后到底是谁执行？是模型自己执行还是说开发者执行？ 函数执行后的返回信息，存储到哪里？然后发送给谁，然后生成什么。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">真正的调用动作由<span style="color: rgb(255, 0, 127);"><b>开发者的代码</b></span>来完成，就是直接将参数传入到这个函数名称里面来调用。<br>返回内容存储在<span style="color: rgb(255, 0, 127);"><b>messages的历史对话</b></span>里面，发送给大模型以后生成<b><span style="color: rgb(255, 0, 127);">最终答案</span></b>。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在 Function Call 机制下，大模型会根据用户的数据来判断调用什么函数【返回的是什么格式以及包含哪些内容】</div>
<div class="separator"></div>
<div class="field_1">返回的是JSON格式，通常包含函数名称和调用所需的参数。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>混合检索是不是先使用文本检索，也就是关键词匹配获取相关文档，然后再使用语义检索对这些检索到的文档进行排序？</div>
<div class="separator"></div>
<div class="field_1">不是的，文本检索跟语义检索是并行的。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>混合检索流程包含两个阶段分别是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ol><li><div><strong>并行检索</strong>：</div><ul><li><span style="color: rgb(255, 0, 127);"><b>文本</b></span>检索（<b><span style="color: rgb(255, 0, 127);">关键词</span></b>匹配）</li><li><span style="color: rgb(255, 0, 127);"><b>语义</b></span>检索（<b><span style="color: rgb(255, 0, 127);">向量</span></b>检索）</li></ul></li><li><div><strong>结果融合</strong>：</div><ul><li>将两种检索方式的结果进行<b><span style="color: rgb(255, 0, 127);">合并</span></b></li><li>使用各种策略（如<span style="color: rgb(255, 0, 127);"><b>投票、加权</b></span>等）<b><span style="color: rgb(255, 0, 127);">确定最终排序</span></b></li></ul></li></ol></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>混合检索流程包含包含哪两种检索方式，以及他们的关系是串行还是并行，以及他们分别针对对是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><b><span style="color: rgb(255, 0, 127);">并行</span></b>检索：
<br><ul><li><span style="color: rgb(255, 0, 127);"><b>文本</b></span>检索（<b><span style="color: rgb(255, 0, 127);">关键词</span></b>匹配）
</li><li><span style="color: rgb(255, 0, 127);"><b>语义</b></span>检索（<b><span style="color: rgb(255, 0, 127);">向量</span></b>检索）</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>重排阶段包含哪几个层次？ 它们的计算成本和速度的区别是什么？以及分别使用什么特征什么模型？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">包括<span style="color: rgb(255, 0, 127);"><b>粗排</b></span>和<span style="color: rgb(255, 0, 127);"><b>精排</b></span>。<br><ul><li>粗排的话，计算<span style="color: rgb(255, 0, 127);"><b>成本低，速度快</b></span>。精排的话，<span style="color: rgb(255, 0, 127);"><b>成本高，更加准确</b></span>。 </li><li>粗排的特点是使用<span style="color: rgb(255, 0, 127);"><b>简单的特征</b></span>，比如<span style="color: rgb(255, 0, 127);"><b>TF IDF分数和BM25分数</b></span>。 精排的话是使用更加复杂的<span style="color: rgb(255, 0, 127);"><b>深度学习模型</b></span>。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>重排阶段包含粗排 和 精排，他们分别的目的是什么？&nbsp; 【筛选出什么文档以及进行什么评估?】</div>
<div class="separator"></div>
<div class="field_1"><ul><li>快速筛选出<b><span style="color: rgb(255, 0, 127);">潜在相关</span></b>文档，</li><li>对候选集进行<b><span style="color: rgb(255, 0, 127);">更精确</span></b>的<span style="color: rgb(255, 0, 127);"><b>相关性评估</b></span>。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>典型的检索系统在从查询向量进入数据库，到拿到最终的结果之前经历了哪2个阶段？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">召回 -&gt; 重排序 -&gt; 最终结果</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>典型的检索系统的流程如下：<br><b><span style="color: rgb(255, 0, 127);">召回</span></b> -&gt; 粗排 -&gt; 精排 -&gt; 最终结果<br>这个召回阶段，它的本质是什么？然后它使用了 哪两种方式以及它的特点是追求什么率，以及容忍什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">它的本质是<span style="color: rgb(255, 0, 127);"><b>混合检索，</b></span>用到了<span style="color: rgb(255, 0, 127);"><b>文本检索和语义检索</b></span> 这两种方式，然后它的特点是追求高的<span style="color: rgb(255, 0, 127);"><b>召回率</b></span>。 容忍一定的<b><span style="color: rgb(255, 0, 127);">噪声</span></b>。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>典型的检索系统的流程如下：<br>召回 -&gt; <b><span style="color: rgb(255, 0, 127);">粗排</span></b> -&gt; 精排 -&gt; 最终结果<br>这个粗排阶段， 它的计算成本以及速度方面是怎么样的，以及使用到了什么特征，以及使用到了什么模型的，以及它的目的是什么。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">它的计算成本<span style="color: rgb(255, 0, 127);"><b>低</b></span>速度<b><span style="color: rgb(255, 0, 127);">快</span></b>，<br>使用到了<span style="color: rgb(255, 0, 127);"><b>简单</b></span>特征（如<span style="color: rgb(255, 0, 127);"><b>TF-IDF</b></span>分数、<span style="color: rgb(255, 0, 127);"><b>BM25</b></span>分数等），<br>使用了轻量级<span style="color: rgb(255, 0, 127);"><b>机器学习</b></span>模型，<br>目的是<span style="color: rgb(255, 0, 127);"><b>快速筛选出潜在相关</b></span>文档。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>典型的检索系统的流程如下：<br>召回 -&gt; 粗排 -&gt; <b><span style="color: rgb(255, 0, 127);">精排</span></b> -&gt; 最终结果<br>这个精排阶段，来计算成本以及准确率是怎么样的，以及使用到了什么模型，以及它的目的是精确的评估什么。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">它的计算成本和 精确率 <span style="color: rgb(255, 0, 127);"><b>都高</b></span>，然后使用的是<span style="color: rgb(255, 0, 127);"><b>深度学习</b></span>模型，它的目的是精确评估<b><span style="color: rgb(255, 0, 127);">相关性</span></b>。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>混合检索里面它使用到了文本检索和语义检索，最终把这两种方式检测到的结果合并，这个过程本质上属于哪个阶段？</div>
<div class="separator"></div>
<div class="field_1">召回阶段。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>重排序阶段，跟精排阶段，和粗排阶段这三个概念之间的关系是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><span style="color: rgb(255, 0, 127);"><b>重排序</b></span> 这个阶段<b><span style="color: rgb(255, 0, 127);">包括 精排 </span></b>和<span style="color: rgb(255, 0, 127);"><b>粗排</b></span> 这两个阶段。&nbsp;<br><br>重排序（Reranking）<br>├── 粗排（Coarse Ranking）<br>└── 精排（Fine Ranking）</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>重排序，精排，粗排，这三个概念分别的英文单词是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">重排序（Reranking）<br>├── 粗排（Coarse Ranking）<br>└── 精排（Fine Ranking）</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>从用户查询到生成最终回答，中间包括哪三个阶段？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">用户查询<br>&nbsp;&nbsp; ↓<br><b><span style="color: rgb(255, 0, 127);">召回</span></b>阶段（文本检索 + 语义检索）<br>&nbsp;&nbsp; ↓<br><b><span style="color: rgb(255, 0, 127);">重排序</span></b>阶段<br>&nbsp;&nbsp; ├── 粗排（Coarse Ranking）<br>&nbsp;&nbsp; └── 精排（Fine Ranking）<br>&nbsp;&nbsp; ↓<br><b><span style="color: rgb(255, 0, 127);">上下文组装</span></b>阶段<br>&nbsp;&nbsp; ↓<br>生成回答</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，从用户查询到生成回答的流程如下。其中，召回阶段和重排序阶段分别包含哪两个部分？&nbsp;<br>用户查询 --&gt;<span style="color: rgb(255, 0, 127);"><b>召回</b></span>阶段&nbsp;--&gt;&nbsp;<span style="color: rgb(255, 0, 127);"><b>重排序</b></span>阶段&nbsp;--&gt;上下文组装阶段&nbsp;--&gt;生成回答<br></div>
<div class="separator"></div>
<div class="field_1">召回阶段（<span style="color: rgb(255, 0, 127);"><b>文本</b></span>检索 + <span style="color: rgb(255, 0, 127);"><b>语义</b></span>检索）<br>&nbsp;&nbsp; ↓<br>重排序阶段<br>&nbsp;&nbsp; ├── <span style="color: rgb(255, 0, 127);"><b>粗排</b></span>（Coarse Ranking）<br>&nbsp;&nbsp; └── <b><span style="color: rgb(255, 0, 127);">精排</span></b>（Fine Ranking）</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>粗排和精排两个子阶段它的总称是什么以及它的目的是对谁的结果进行优化排序？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">他的总称是<span style="color: rgb(255, 0, 127);"><b>重排序ranking，<br></b></span>目的是优化<b><span style="color: rgb(255, 0, 127);">召回/检索的结果的排序</span></b>。&nbsp;&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，<br>将查询到的上下文进行组装。进入到这个阶段之前经历过哪两个阶段？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">查询处理 -&gt; <b><span style="color: rgb(255, 0, 127);">召回阶段</span></b> -&gt; <span style="color: rgb(255, 0, 127);"><b>重排序阶段</b></span> -&gt; 上下文组装 -&gt; 生成回答</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">all-MiniLM-L6-v2&nbsp;<br>这个模型实际上是哪个框架的一个具体模型实现。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">Sentence-BERT (SBERT) 框架。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT (SBERT) 框架 ，其中，在应用里面使用了这个框架的哪一个具体模型？&nbsp; &nbsp;</div>
<div class="separator"></div>
<div class="field_1">all-MiniLM-L6-v2&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">导入all-MiniLM-L6-v2这个模型的具体的代码是什么？&nbsp; 【from sentence_transformers 还是from SentenceTransformer】</div>
<div class="separator"></div>
<div class="field_1"># 导入SBERT框架<br>from sentence_transformers import <span style="color: rgb(255, 0, 127);"><b>SentenceTransformer</b></span><br><br># 加载具体的SBERT模型<br>model = SentenceTransformer('<b><span style="color: rgb(255, 0, 127);">all-MiniLM-L6-v2</span></b>')</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">all-MiniLM-L6-v2这个模型名称 各个部分的含义是什么？ 如何拆解理解呢？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li><code>all</code>: 表示这个模型经过多任务训练</li><li><code>MiniLM</code>: 底层使用的基础模型架构</li><li><code>L6</code>: 6层网络结构</li><li><code>v2</code>: 第二个版本</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">all-MiniLM-L6-v2这个模型是具体通过导入哪个库来使用。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">sentence-transformers库。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 这个模型作为嵌入模型它的优势是什么？&nbsp;&nbsp;【专门针对谁进行优化？】</div>
<div class="separator"></div>
<div class="field_1"><ul><li>专门针对句子相似度优化</li><li>计算效率高</li><li>语义理解能力强</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 这个模型作为嵌入模型，它的适用场景是什么？&nbsp;【什么计算，什么搜索，什么匹配？】</div>
<div class="separator"></div>
<div class="field_1">- 文本相似度计算<br>- 语义搜索<br>- 文档匹配</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 这个模型作为嵌入模型，还是用于重排模型？</div>
<div class="separator"></div>
<div class="field_1">嵌入模型.</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在项目中使用哪个框架进行文本嵌入？具体使用了哪个模型？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">"在项目中，我使用了<span style="color: rgb(255, 0, 127);"><b>Sentence-BERT</b></span>框架进行文本嵌入，具体实现选择了<b><span style="color: rgb(255, 0, 127);">all-MiniLM-L6-v2</span></b>这个模型。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 和 all-MiniLM-L6-v2 这两个名称它们之间的关系是什么？&nbsp; &nbsp;</div>
<div class="separator"></div>
<div class="field_1">Sentence-BERT是一个用于<span style="color: rgb(255, 0, 127);"><b>文本嵌入的框架</b></span>，而all-MiniLM-L6-v2是该框架下的一个<b><span style="color: rgb(255, 0, 127);">具体实现模型</span></b>，它是经过知识蒸馏优化的轻量级模型，在保持良好性能的同时大大提升了计算效率。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">all-MiniLM-L6-v2&nbsp; 是通过什么方式得到的轻量级框架？&nbsp;他的基础架构是继承了谁？</div>
<div class="separator"></div>
<div class="field_1">它是经过<b><span style="color: rgb(255, 0, 127);">知识蒸馏优化</span></b>的轻量级模型，在保持良好性能的同时大大提升了计算效率。&nbsp;<br>他继承了bert的基础架构。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">为什么选择&nbsp;all-MiniLM-L6-v2 这个模型作为我们的文本嵌入模型。&nbsp;<br>【它输出向量是什么维度，然后能够更好地捕获什么，然后有几层的什么架构？ 然后模型大小是多少？ 适合什么？ 】</div>
<div class="separator"></div>
<div class="field_1">1. 模型效果好：输出<span style="color: rgb(255, 0, 127);"><b>384维</b></span>的向量，能很好地捕捉<span style="color: rgb(255, 0, 127);"><b>文本语义</b></span><br>2. 计算效率高：<span style="color: rgb(255, 0, 127);"><b>6层transformer</b></span>结构，推理速度快<br>3. 资源占用小：模型只有约<span style="color: rgb(255, 0, 127);"><b>80MB</b></span>，适合<b><span style="color: rgb(255, 0, 127);">生产部署</span></b><br></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统里面，嵌入模型的最大输入长度Input Length 是否决定了文档分块的大小Chunk Size？ 以及为什么？</div>
<div class="separator"></div>
<div class="field_1"><b><span style="color: rgb(255, 0, 127);">不是</span></b>的，这两个大小可以不一样。 <br>文档分块的大小尺寸<span style="color: rgb(255, 0, 127);"><b>可以大于</b></span>嵌入模型的最大输入长度，因为模型会<b><span style="color: rgb(255, 0, 127);">自动处理超长的输入</span></b>，会在<b><span style="white-space: pre-wrap; color: rgb(255, 0, 127);">内部会进行截断。</span></b></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统里面，嵌入模型all-MiniLM-L6-v2模型 输入长度限制是什么，超过这个长度限制以后会怎么样？然后他的嵌入维度是多少？模型大小是什么？每秒能处理多少个句子？<br>以及文档分块的时候chunk size分块大小是分别是多少？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">256，超过这个长度以后会被截断，他的嵌入维度是384。模型大小是80MB.每秒处理14000多个句子。<br> chunk size分块大小是 512.</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统里面， 文本块chunks的长度是否可以大于嵌入模型的输入限制？ 如果可以的话，该采取什么方式来处理呢？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">文本块<span style="color: rgb(255, 0, 127);"><b>可以大于</b></span>嵌入模型的输入限制时，通常会采用<b><span style="color: rgb(255, 0, 127);">截断</span></b>或其他处理方式来适应模型。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统里面， 对文档进行分块chunks过程中的优化改进点是什么？<br>在回答这个面试问题的时候 <b><span style="color: rgb(255, 0, 127);">回答思路</span></b>是什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ol><li>先简要概述<b><span style="color: rgb(255, 0, 127);">基础策略</span></b></li><li>重点展开 <b><span style="color: rgb(255, 0, 127);">2-3</span></b> 个核心<span style="color: rgb(255, 0, 127);"><b>优化点</b></span></li><li>结合<b><span style="color: rgb(255, 0, 127);">实际项目</span></b>经验说明优化<span style="color: rgb(255, 0, 127);"><b>效果</b></span></li><li>提到一些具体的<span style="color: rgb(255, 0, 127);"><b>技术</b></span>实现（如使用的<b><span style="color: rgb(255, 0, 127);">工具和库</span></b>）</li><li>强调这些优化对<b><span style="color: rgb(255, 0, 127);">检索质量</span></b>的<span style="color: rgb(255, 0, 127);"><b>提升</b></span></li></ol></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统里面，&nbsp;基础分块策略优化是什么?以及这样的好处是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">chunk size 512, overlap 50.<br><div>分块大小（512 tokens）和重叠窗口（50 tokens），这样可以保证基本的上下文连贯性。</div><div><br></div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Spacy 这个软件包它的使用的领域是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">NLP，自然语言处理。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Spacy 和 NLTK，这两个工具他们使用场景的区别是什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li><div>更侧重<span style="color: rgb(255, 0, 127);"><b>工业应用</b></span>，专门为<span style="color: rgb(255, 0, 127);"><b>生产环境</b></span>设计，能<b><span style="color: rgb(255, 0, 127);">高效</span></b>处理<span style="color: rgb(255, 0, 127);"><b>大量文本</b></span>数据，</div></li><li><div>更偏向于<span style="color: rgb(255, 0, 127);"><b>学术研究</b></span>以及<b><span style="color: rgb(255, 0, 127);">教学</span></b>目的。&nbsp;</div></li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在RAG系统中，使用了Spacy框架，主要的用途是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><span style="background-color: oklch(0.99 0.004 106.471);"><span style="color: oklch(0.304 0.04 213.681);">主要用于</span><b><span style="color: rgb(255, 0, 127);">文本分块（Text Splitting）</span></b><span style="color: oklch(0.304 0.04 213.681);">环节，这是RAG系统数据预处理的关键步骤。</span></span></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在RAG系统中，使用了Spacy框架 来进行分块，这样做的好处是什么？&nbsp; 【基于什么来进行切分，避免什么？】</div>
<div class="separator"></div>
<div class="field_1"><span style="color: rgb(255, 0, 127);"><b>语义</b></span>感知<span style="color: rgb(255, 0, 127);"><b>分块</b></span>，基于自然段落和章节<span style="color: rgb(255, 0, 127);"><b>边界进行分块</b></span>，<b><span style="color: rgb(255, 0, 127);">避免在句子中间截断</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统开发 是基于哪个框架以及为什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">基于LangChain ，因为提供完整的 RAG 开发组件。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统开发框架是什么？</div>
<div class="separator"></div>
<div class="field_1">LangChain 。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RecursiveCharacterTextSplitter vs SpacyTextSplitter<br>这两个文本分割器，各自的优缺点是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>RecursiveCharacterTextSplitter：优点就是速度快。缺点就是可能导致语义不完整。&nbsp;</li><li>SpacyTextSplitter：优点就是可以保证语义完整，句子完整。但是 处理速度慢，内存消耗大。&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">OpenAI Embeddings vs SBERT<br>这两个嵌入模型，各自的优缺点是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>OpenAI Embeddings：优点就是效果好，使用简单，缺点是需要付费， 需要网络。&nbsp;</li><li>SBERT：优点是开源免费，而且的话体积小方便部署。缺点就是效果不如open AI。&nbsp;&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Bi-Encoder Cross-Encoder<br>这两个架构分别对应的中文是什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">双编码器（Bi-Encoder）和跨编码器（Cross-Encoder）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">双编码器 和跨编码器&nbsp;<br>这两个架构分别对应的英文是什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">双编码器（Bi-Encoder）和跨编码器（Cross-Encoder）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">双编码器通常用于RAG系统中的哪个模型？&nbsp; 它的主要作用是将什么和什么编码成什么。 然后通过什么来快速检索什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><span style="color: rgb(255, 0, 127);"><b>嵌入模型</b></span>阶段。它的主要作用是将<span style="color: rgb(255, 0, 127);"><b>查询</b></span>和<span style="color: rgb(255, 0, 127);"><b>文档</b></span>分别编码为<span style="color: rgb(255, 0, 127);"><b>固定维度的向量表示</b></span>，然后通过<span style="color: rgb(255, 0, 127);"><b>向量相似性（如余弦相似度）</b></span>来快速检索<b><span style="color: rgb(255, 0, 127);">相关文档。</span></b></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统 里面，我使用的双编码器是哪个？</div>
<div class="separator"></div>
<div class="field_1">all-MiniLM-L6-v2。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">跨编码器通常用于RAG系统中的哪个阶段的哪个模型？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><span style="color: rgb(255, 0, 127);"><b>重排序</b></span>阶段，即<b><span style="color: rgb(255, 0, 127);">精排</span></b>模型。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">跨编码器通常用于RAG系统中，它将什么和什么作为输入，并且通过什么架构来对其联合编码而输出一个什么，然后用于什么。&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">它直接将<span style="color: rgb(255, 0, 127);"><b>查询</b></span>和<span style="color: rgb(255, 0, 127);"><b>候选文档</b></span>作为输入，并通过<span style="color: rgb(255, 0, 127);"><b>Transformer</b></span>架构对其进行联合编码，输出一个<span style="color: rgb(255, 0, 127);"><b>相关性评分</b></span>，用于<b><span style="color: rgb(255, 0, 127);">重新排序候选文档。</span></b></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">跨编码器和双编码器谁更适合高精度场景以及因为它可以访问什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><b><span style="color: rgb(255, 0, 127);">跨编码器</span></b>更适合，因为跨编码器可以<b><span style="color: rgb(255, 0, 127);">同时访问查询和候选文档的完整上下文信息</span></b>，其性能通常优于双编码器。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">为什么跨编码器不适合大规模检索？</div>
<div class="separator"></div>
<div class="field_1">因为它的精度高，效率低，而且计算成本高。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在RAG项目里面使用到的这个跨编码器模型叫什么名字？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">ms-marco-MiniLM-L-12-v2。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在RAG项目里面，<br>双编码器跟跨编码器它们分别用于什么场景？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><div>双编码器适合用于<b><span style="color: rgb(255, 0, 127);">文本嵌入以及初步检索</span></b>（retrieval），</div><div>跨编码器适合用于<b><span style="color: rgb(255, 0, 127);">重排序</span></b>（reranking）。</div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在RAG系统中，通常会结合使用哪两种架构：<br>先使用哪个结构干什么然后再使用哪个结构干什么？ 从而在效率和精度之间取得平衡</div>
<div class="separator"></div>
<div class="field_1">先用<span style="color: rgb(255, 0, 127);"><b>双编码器</b></span>进行<span style="color: rgb(255, 0, 127);"><b>文本嵌入和初步检索</b></span>，再用<span style="color: rgb(255, 0, 127);"><b>跨编码器</b></span>对候选结果进行<b><span style="color: rgb(255, 0, 127);">精排</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0"><span style="color: rgb(255, 0, 127);"><b>ms-marco</b></span>-MiniLM-L-12-v2&nbsp;和&nbsp;<b><span style="color: rgb(255, 0, 127);">all</span></b>-MiniLM-L6-v2,&nbsp;<br>其中，ms-marco 和 all&nbsp; 如何从这两个名字里面看出区别？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>ms-marco 代表的是一个特定的专注于<b><span style="color: rgb(255, 0, 127);">信息检索</span></b>和问答任务的<span style="color: rgb(255, 0, 127);"><b>大规模数据集</b></span>。&nbsp;&nbsp;</li><li>all 代表的是，它是一个<span style="color: rgb(255, 0, 127);"><b>通用模型</b></span>，适用于多种任务，而<b><span style="color: rgb(255, 0, 127);">不是针对特定数据集</span></b>训练。&nbsp;&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0"><span style="color: rgb(255, 0, 127);"><b>ms-marco</b></span>-MiniLM-L-12-v2&nbsp;和&nbsp;<b><span style="color: rgb(255, 0, 127);">all</span></b>-MiniLM-L6-v2,&nbsp;<br>其中，哪一个是双编码器架构？哪一个是跨编码器架构？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">前者是<span style="color: rgb(255, 0, 127);"><b>跨</b></span>编码器架构，<br>后者是<b><span style="color: rgb(255, 0, 127);">双</span></b>编码器架构。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">ms-marco-MiniLM-<span style="color: rgb(255, 0, 127);"><b>L-12</b></span>-v2&nbsp;和&nbsp;all-MiniLM-<span style="color: rgb(255, 0, 127);"><b>L6</b></span>-v2,&nbsp;<br>名称中的&nbsp;L6&nbsp;和&nbsp;L12&nbsp;表示 什么意思？数字大小不同会分别造成什么影响？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">表示<b><span style="color: rgb(255, 0, 127);">Transformer 的层数</span></b>。<br>12 层 Transformer 编码器，模型更深，能<span style="color: rgb(255, 0, 127);"><b>捕获更复杂的语义特征</b></span>，效果更好，但速度更慢。&nbsp;<br>6 层 Transformer 编码器，模型较轻量化，推理<span style="color: rgb(255, 0, 127);"><b>速度快</b></span>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0"><span style="color: rgb(255, 0, 127);"><b>ms-marco</b></span>-MiniLM-<span style="color: rgb(255, 0, 127);"><b>L-12</b></span>-v2&nbsp;和&nbsp;<b><span style="color: rgb(255, 0, 127);">all</span></b>-MiniLM-<span style="color: rgb(255, 0, 127);"><b>L6</b></span>-v2,&nbsp;<br>名字中的关键词（如&nbsp;ms-marco&nbsp;和&nbsp;all），以及层数标识 (L6&nbsp;vs.&nbsp;L12) 如何来快速识别它们的用途和特点？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>ms-marco,表示的是微软的特定的用于信息检索的数据库。 专门在这个数据库上进行训练。 L12 表示层数是12个transformer层，层数非常深，可以捕获更加复杂的语义特征。效果更好，但速度更慢。&nbsp;</li><li>all，表示的是，它是通用的模型，不针对特定的任务。 不针对特定的数据集。L6&nbsp; 表示，它的层数是6层。 因此速度更快，更加高效。&nbsp;&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">双编码器生成的嵌入可以直接用于计算什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">用于相似度计算。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">&nbsp;为什么跨编码器的计算成本较高？&nbsp; 【查询和文档进行怎么样的比较？】</div>
<div class="separator"></div>
<div class="field_1">跨编码器需要对每个候选文档与查询进行逐一比较，因此其计算成本较高。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">双编码器它是生成什么向量，然后用于快速计算什么度？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">生成可重用的<span style="color: rgb(255, 0, 127);"><b>稠密</b></span>向量，可以快速计算<b><span style="color: rgb(255, 0, 127);">相似度。</span></b></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面使用到的嵌入模型和重排模型分别是什么？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>all-MiniLM-L6-v2&nbsp;</li><li>ms-marco-MiniLM-L-12-v2&nbsp;</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面 重排序阶段的粗排，使用的技术方案是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">BM25 + TF-IDF 结合打分。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">不建议在 RAG 系统中使用双编码器作为粗排模型，这是为什么呢？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">因为双编码器生成的向量在<span style="color: rgb(255, 0, 127);"><b>【混合检索里面的向量检索】初始检索时已经被计算过</b></span>，重复使用相同模型可能<b><span style="color: rgb(255, 0, 127);">不会带来新的收益</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">双编码器生成的向量叫做什么向量，通常是否是 预先计算好，存储在哪里？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><span style="background-color: oklch(0.99 0.004 106.471);"><span style="color: oklch(0.304 0.04 213.681);">双编码器生成的</span><b><span style="color: rgb(255, 0, 127);">稠密</span></b><span style="color: oklch(0.304 0.04 213.681);">向量（</span><b><span style="color: rgb(255, 0, 127);">dense </span></b><span style="color: oklch(0.304 0.04 213.681);">embeddings）通常在</span><b><span style="color: rgb(255, 0, 127);">离线阶段预先计算</span></b></span><b><span style="color: rgb(255, 0, 127);">好</span></b>，并存储在<b><span style="color: rgb(255, 0, 127);">向量数据库</span></b>中（如&nbsp;FAISS）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，查询时候的初始语义检索是将什么和什么进行&nbsp; 计算什么来完成。&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><div>系统只需将<span style="color: rgb(255, 0, 127);"><b>查询向量</b></span>与<span style="color: rgb(255, 0, 127);"><b>文档向量</b></span>进行<b><span style="color: rgb(255, 0, 127);">相似度</span></b>计算即可完成初始检索。</div></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0"><div>如果RAG系统设计中，双编码器已经用于初始检索，是否建议在粗排阶段重复使用相同的双编码器，以及为什么？</div></div>
<div class="separator"></div>
<div class="field_1">不建议，因为不会引入额外的信息增益。 不会带来显著收益。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">相似度计算 是指直接比较谁和谁之间的相似性，用于衡量在哪里的什么程度。常用的方法包括哪两种。&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">相似度计算是指直接比较<span style="color: rgb(255, 0, 127);"><b>查询向量</b></span>和<span style="color: rgb(255, 0, 127);"><b>候选文档向量</b></span>之间的相似性，用于衡量<span style="color: rgb(255, 0, 127);"><b>它们在语义空间中的接近程度</b></span>。常用的方法包括<b><span style="color: rgb(255, 0, 127);">余弦相似度、欧几里得距离等。</span></b></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">最近邻搜索是一种什么技术？它从哪里找到与谁最接近的几个向量？它有哪两种方式？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">最近邻搜索（Nearest Neighbor Search, NNS）是一种<span style="color: rgb(255, 0, 127);"><b>高效检索</b></span>技术，用于从<span style="color: rgb(255, 0, 127);"><b>大规模向量数据库</b></span>中找到与<span style="color: rgb(255, 0, 127);"><b>查询向量</b></span>最接近的<span style="color: rgb(255, 0, 127);"><b> K 个向量</b></span>。它可以是<span style="color: rgb(255, 0, 127);"><b>精确</b></span>最近邻搜索（k-NN）或<span style="color: rgb(255, 0, 127);"><b>近似</b></span>最近邻搜索（ANN）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统的第一步通常是通过 ANN 近似最近邻算法从哪里快速筛选出什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">从<span style="color: rgb(255, 0, 127);"><b>大规模文档库</b></span>中快速筛选出一个<b><span style="color: rgb(255, 0, 127);">较小的候选集合</span></b>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 系统的第一步为什么是 ANN 近似最近邻算法？【通过牺牲什么来换来什么的提升。】</div>
<div class="separator"></div>
<div class="field_1">因为它是近似最近邻算法。 会牺牲掉一部分精确性，但是会换来显著的性能提升。适合大规模数据集，效率非常高。&nbsp;&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">在 RAG 系统中，<br>初始向量检索阶段 ，使用的是近似最近邻算法还是余弦相似度算法？</div>
<div class="separator"></div>
<div class="field_1">ANN 近似最近邻搜索，而这个近似最近邻搜索算法的底层使用到的是余弦相似度，欧几里的距离，内积这些算法。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稀疏检索&nbsp; 是基于传统的还是现代的检索方法，两个例子分别是什么？它们依赖于什么匹配，而通过统计什么和什么来衡量什么和什么之间的关联性。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">基于<span style="color: rgb(255, 0, 127);"><b>传统</b></span>的信息检索方法，如 <span style="color: rgb(255, 0, 127);"><b>BM25 </b></span>或<span style="color: rgb(255, 0, 127);"><b> TF-IDF</b></span>。这些方法依赖于<b><span style="color: rgb(255, 0, 127);">关键词</span></b>匹配，通过统计<span style="color: rgb(255, 0, 127);"><b>词频</b></span>和<span style="color: rgb(255, 0, 127);"><b>逆文档频率</b></span>来衡量<span style="color: rgb(255, 0, 127);"><b>文档</b></span>与<span style="color: rgb(255, 0, 127);"><b>查询</b></span>之间的相关性。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稀疏检索&nbsp; 它的优缺点分别是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li><div>优势：<span style="color: rgb(255, 0, 127);"><b>速度快 </b></span>、实现<b><span style="color: rgb(255, 0, 127);">简单</span></b>，对<span style="color: rgb(255, 0, 127);"><b>关键词匹配效果好</b></span>。</div></li><li><div>劣势：<b><span style="color: rgb(255, 0, 127);">缺乏语义理解</span></b>能力，无法处理同义词或上下文依赖。</div></li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稠密检索 是利用什么来生成什么，将什么和什么映射到哪里？通过计算什么来衡量相关性。 </div>
<div class="separator"></div>
<div class="field_1">基于<span style="color: rgb(255, 0, 127);"><b>深度学习模型</b></span>生成的<span style="color: rgb(255, 0, 127);"><b>嵌入表示</b></span>，将<span style="color: rgb(255, 0, 127);"><b>查询</b></span>和<span style="color: rgb(255, 0, 127);"><b>文档</b></span>映射到<span style="color: rgb(255, 0, 127);"><b>同一语义空间</b></span>，并通过<span style="color: rgb(255, 0, 127);"><b>向量相似性</b></span>来衡量相关性。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稀疏检索 和 稠密检索，<br>分别是基于什么来进行匹配？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>基于关键词匹配，</li><li>基于语义匹配。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稀疏检索 和 稠密检索，<br>分别使用的技术是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>BM25, TF-IDF，</li><li>近似最近邻算法。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稀疏检索 和 稠密检索，<br>分别使用的优点是什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1"><ul><li>快速、高效、易解释，</li><li>深层语义理解能力强。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稀疏检索 和 稠密检索，<br>分别使用的使用场景 是什么任务？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">文本或关键词的匹配任务。<br>问答对话任务 。<br><ul><li>精确关键词匹配任务，</li><li>开放域问答、对话系统等复杂任务。</li></ul></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">稠密向量检索，也就是基于向量的检索，它的资源的消耗比较大。那么大规模数据上使用什么技术来实现高效的语义搜索？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">ANN 近似最近邻搜索。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">最近邻搜索ANN 是否进行了相似度计算？</div>
<div class="separator"></div>
<div class="field_1">是的。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG里面，在后续排序或精排阶段，通过更精确的相似度计算方法（如余弦相似度）进一步优化排序，这个说法正确吗？以及为什么？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">不正确，因为在精排阶段，Cross-Encoder则是直接通过神经网络对查询-文档对进行打分，不需要使用余弦相似度计算。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">ms-marco-MiniLM-L-12-v2 这个模型的架构是什么？专门设计用来计算什么和什么的评分任务？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">&nbsp;是一个&nbsp;跨编码器（Cross-Encoder）&nbsp;模型，专门设计用于查询和候选段落的相关性评分任务。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">跨编码器（Cross-Encoder）架构设计需要同时输入哪些内容？&nbsp; &nbsp;</div>
<div class="separator"></div>
<div class="field_1">&nbsp;&nbsp;需要同时输入查询和候选段落。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">跨编码器（Cross-Encoder）架构 将查询和候选段落拼接成一个什么？然后输入到哪里？&nbsp;计算出什么？</div>
<div class="separator"></div>
<div class="field_1">拼接成一个输入序列，作为整体输入到 Transformer 模型中。计算出一个相关性分数。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 里面的重排序阶段 粗排和精排分别用的是什么模型？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">LightGBM，<br>Cross Encoder里面的ms-marco-MiniLM-L-12-v2。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG 里面的重排序阶段 粗排和精排分别&nbsp; 使用轻量级的机器学习模型，以及使用复杂的跨编码器模型。这是为什么呢？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">因为粗排阶段是需要处理大量的候选文档，<br>而精排的话则是需要精度。&nbsp;&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 它的本质是什么，以及它是基于什么来改进的。</div>
<div class="separator"></div>
<div class="field_1">它的本质是一个<b><span style="color: rgb(255, 0, 127);">模型架构</span></b>，它是基于<span style="color: rgb(255, 0, 127);"><b>Bert</b></span>来改进的。&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 从名字上就可以看出专门适用于什么。&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">专门设计用于生成句子级别的嵌入表示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 从名字上就可以看出他们专门适用于什么。&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">专门设计用于生成<b><span style="color: rgb(255, 0, 127);">句子级别的嵌入</span></b>表示。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">Sentence-BERT 为什么被通常认为是一个嵌入模型？&nbsp;</div>
<div class="separator"></div>
<div class="field_1">因为<span style="color: oklch(0.304 0.04 213.681); background-color: oklch(0.99 0.004 106.471);">核心功能是生成高质量的文本嵌入（dense embeddings）。</span></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">ms-marco-MiniLM-L-12-v2&nbsp;通常用于 RAG 系统中的哪个阶段？</div>
<div class="separator"></div>
<div class="field_1">&nbsp;重排序（Re-ranking）精排阶段。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，跨编码器模型 它的输入和输出分别是什么？ 目的是将文档怎么样？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">输入是查询和候选文档，<br>输出是相关性分数，<br>目的是根据得分，将文档进行重新排序。&nbsp;&nbsp;</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">RAG系统里面，粗排阶段的目标是 利用哪个阶段得到的什么东西 来怎么样处理， 最终得到一个候选集合。&nbsp;</div>
<div class="separator"></div>
<div class="field_1">从<span style="color: rgb(255, 0, 127);"><b>召回</b></span>的<span style="color: rgb(255, 0, 127);"><b>大量候选文档</b></span>中快速<b><span style="color: rgb(255, 0, 127);">筛选</span></b>出一个较小的候选集合（通常从数千到数百）。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">ms-marco-<b><span style="color: rgb(255, 0, 127);">MiniLM</span></b>-L-12-v2 <br>这个模型里面的MiniLM这个单词表示什么意思？&nbsp;&nbsp;</div>
<div class="separator"></div>
<div class="field_1">表示采用了 MiniLM（Miniature Language Model）<span style="color: rgb(255, 0, 127);"><b>架构</b></span>，它是一种<b><span style="color: rgb(255, 0, 127);">轻量化的 Transformer </span></b>模型，专注于在保持性能的同时<span style="color: rgb(255, 0, 127);"><b>降低计算成本</b></span>。</div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">跨编码器（Cross-Encoder），其核心工作原理是什么？<br>【将什么跟什么拼接成什么，然后格式是什么样的？然后12层transformer对谁怎么样？提取哪个向量，经过哪个层计算得到什么？】</div>
<div class="separator"></div>
<div class="field_1"><ol><li><div><strong>输入处理</strong>：将查询和候选段落<b><span style="color: rgb(255, 0, 127);">拼接成一个序列</span></b>，格式为&nbsp;<code>&lt;CLS&gt; query &lt;SEP&gt; passage &lt;SEP&gt;</code>。</div></li><li><div><strong>Transformer 编码</strong>：通过 <b><span style="color: rgb(255, 0, 127);">12 层 Transformer </span></b>对输入序列进行编码。</div></li><li><div><strong>相关性评分</strong>：模型<span style="color: rgb(255, 0, 127);"><b>提取&nbsp;<code>&lt;CLS&gt;</code>&nbsp;标记</b></span>的向量表示，并通过<span style="color: rgb(255, 0, 127);"><b>分类层计算</b></span>出查询与段落之间的<b><span style="color: rgb(255, 0, 127);">相关性分数</span></b>。</div></li><li><div><strong>排序</strong>：根据相关性分数对候选段落进行<b><span style="color: rgb(255, 0, 127);">降序排列</span></b>，从而将最相关的段落排在前面&nbsp;</div></li></ol></div>
</div>
<div class="card">
<div class="tags" aria-hidden="true">Tags: 导入Edge::2-19</div>
<div class="field_0">介绍一下ms-marco-MiniLM-L-12-v2 模型【名字上解释？它属于什么架构以及它的使用场景是什么？核心工作原理是什么？ 】</div>
<div class="separator"></div>
<div class="field_1"><ol><li>它是基于微软的ms-marco数据集来进行训练。&nbsp;使用的是MiniLM框架，这是一个轻量化的transformer架构，具有12个层。&nbsp;</li><li>它是Cross Encoder架构，然后用于重排序阶段里面的精排阶段。</li><li>将查询跟文档拼接成一个序列，然后通过12个transformer层进行编码，然后通过CLS标记经过 分类层，计算出相应的得分，最后再按照降序来排序。&nbsp;&nbsp;</li></ol></div>
</div>

<script>
document.addEventListener('click', function(e) {
const container = e.target.closest('.video-container');
if (!container) return;

const placeholder = container.querySelector('.video-placeholder');
if (!placeholder) return;

const videoId = container.dataset.videoId;
const startParam = container.dataset.start || '';

const iframe = document.createElement('iframe');
iframe.width = '100%';
iframe.height = '100%';
iframe.src = `https://www.youtube.com/embed/${videoId}?${startParam.slice(1)}`;
iframe.title = 'YouTube video player';
iframe.frameBorder = '0';
iframe.style.position = 'absolute';
iframe.style.top = '0';
iframe.style.left = '0';
iframe.style.borderRadius = '15px';
iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
iframe.allowFullscreen = true;

placeholder.innerHTML = '';
placeholder.appendChild(iframe);
});
</script>

</div>
<div class="footer">Made by <a href="https://xxhk.org">Export Notes - XXHK</a></div>
</body>
</html>

