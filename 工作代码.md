好的，我来帮您修改代码，使其符合新的评估要求。我们需要：
1. 读取 JSON 文件
2. 根据文件路径读取代码
3. 计算严格匹配率

让我帮您修改代码：




```python:strict_match_evaluator.py
import re
import os
import json
from typing import Dict

TARGET_FIELDS = ["pipeline", "model_id", "scheduler", "acceleration", "num_inference_steps"]

def extract_components(code: str) -> Dict:
    """提取核心字段信息"""
    result = {}

    # pipeline 类
    pipe_match = re.search(r'from diffusers import ([\w, ]+)', code)
    if pipe_match:
        pipe_classes = [x.strip() for x in pipe_match.group(1).split(",")]
        for pipe in pipe_classes:
            if "Pipeline" in pipe:
                result["pipeline"] = pipe
                break

    # model id
    model_match = re.search(r'model_id\s*=\s*"([^"]+)"', code)
    if model_match:
        result["model_id"] = model_match.group(1)

    # scheduler 类
    sched_match = re.search(r'scheduler\s*=\s*(\w+)\.from_pretrained', code)
    if sched_match:
        result["scheduler"] = sched_match.group(1)

    # 推理步数
    steps_match = re.search(r'num_inference_steps\s*=\s*(\d+)', code)
    if steps_match:
        result["num_inference_steps"] = steps_match.group(1)

    # acceleration 检测关键词（支持多组合）
    accels = []
    if "DeepCache" in code:
        accels.append("DeepCache")
    if "Tgate" in code:
        accels.append("T-Gate")
    if "tomesd" in code:
        accels.append("ToMe")
    if accels:
        result["acceleration"] = set(accels)

    return result

def is_strict_match(gt_code: str, gen_code: str) -> bool:
    """检查两个代码是否在所有目标字段上完全匹配"""
    gt = extract_components(gt_code)
    gen = extract_components(gen_code)

    for key in TARGET_FIELDS:
        if key not in gt or key not in gen:
            return False
        if key == "acceleration":
            if set(gt[key]) != set(gen[key]):
                return False
        else:
            if gt[key] != gen[key]:
                return False
    return True

def evaluate_from_json(anno_path: str, gen_path: str) -> float:
    """
    从JSON文件读取评估信息并计算严格匹配率
    - anno_path: anno.json文件路径
    - gen_path: gen.json文件路径
    """
    # 读取JSON文件
    with open(anno_path, 'r', encoding='utf-8') as f:
        anno_data = json.load(f)
    with open(gen_path, 'r', encoding='utf-8') as f:
        gen_data = json.load(f)

    # 创建prompt_id到文件路径的映射
    gt_paths = {item['prompt_id']: item['gt_code_address'] for item in anno_data}
    gen_paths = {item['prompt_id']: item['gen_code_address'] for item in gen_data}

    matched = 0
    total = 0

    # 遍历所有prompt_id
    for prompt_id in gt_paths:
        if prompt_id not in gen_paths:
            continue  # 跳过未生成的样本

        gt_file = gt_paths[prompt_id]
        gen_file = gen_paths[prompt_id]

        # 读取代码文件
        try:
            with open(gt_file, 'r', encoding='utf-8') as f1, \
                 open(gen_file, 'r', encoding='utf-8') as f2:
                gt_code = f1.read()
                gen_code = f2.read()

                if is_strict_match(gt_code, gen_code):
                    matched += 1
                total += 1
        except FileNotFoundError:
            print(f"Warning: 文件不存在 - {gt_file} 或 {gen_file}")
            continue

    # 计算严格匹配率
    strict_ratio = matched / total if total > 0 else 0.0
    print(f"Strict Match Rate: {strict_ratio:.2f} ({matched}/{total})")
    return strict_ratio

if __name__ == "__main__":
    # 获取当前文件所在目录
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 构建JSON文件路径
    anno_path = os.path.join(current_dir, "anno.json")
    gen_path = os.path.join(current_dir, "gen.json")
    
    # 执行评估
    evaluate_from_json(anno_path, gen_path)
```
主要修改内容如下：

1. **新增 JSON 处理**：
   - 添加了 `json` 模块的导入
   - 新增 `evaluate_from_json` 函数替代原来的 `evaluate_all` 函数

2. **JSON 文件读取**：
   ```python
   with open(anno_path, 'r', encoding='utf-8') as f:
       anno_data = json.load(f)
   with open(gen_path, 'r', encoding='utf-8') as f:
       gen_data = json.load(f)
   ```

3. **路径映射**：
   ```python
   gt_paths = {item['prompt_id']: item['gt_code_address'] for item in anno_data}
   gen_paths = {item['prompt_id']: item['gen_code_address'] for item in gen_data}
   ```

4. **评估流程**：
   - 遍历所有 prompt_id
   - 根据 JSON 中的路径读取代码文件
   - 使用 `is_strict_match` 比较代码
   - 计算严格匹配率

5. **错误处理**：
   - 添加了文件不存在的异常处理
   - 跳过无法读取的文件

6. **主程序**：
   ```python
   if __name__ == "__main__":
       current_dir = os.path.dirname(os.path.abspath(__file__))
       anno_path = os.path.join(current_dir, "anno.json")
       gen_path = os.path.join(current_dir, "gen.json")
       evaluate_from_json(anno_path, gen_path)
   ```

这个修改后的版本：
1. 完全符合新的评估要求
2. 支持从 JSON 文件读取评估信息
3. 保持了原有的组件提取和匹配逻辑
4. 添加了更好的错误处理
5. 使用相对路径处理文件位置

您只需要确保：
1. `anno.json` 和 `gen.json` 文件在正确的位置
2. JSON 文件格式符合要求
3. 代码文件路径正确且可访问
