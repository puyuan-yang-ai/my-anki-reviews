好的，我来帮您修改代码，使其符合新的评估要求。我们需要：
1. 读取 JSON 文件
2. 根据文件路径读取代码
3. 计算严格匹配率

让我帮您修改代码：




```python:strict_match_evaluator.py
import re
import os
import json
from typing import Dict

TARGET_FIELDS = ["pipeline", "model_id", "scheduler", "acceleration", "num_inference_steps"]

def extract_components(code: str) -> Dict:
    """提取核心字段信息"""
    result = {}

    # pipeline 类
    pipe_match = re.search(r'from diffusers import ([\w, ]+)', code)
    if pipe_match:
        pipe_classes = [x.strip() for x in pipe_match.group(1).split(",")]
        for pipe in pipe_classes:
            if "Pipeline" in pipe:
                result["pipeline"] = pipe
                break

    # model id
    model_match = re.search(r'model_id\s*=\s*"([^"]+)"', code)
    if model_match:
        result["model_id"] = model_match.group(1)

    # scheduler 类
    sched_match = re.search(r'scheduler\s*=\s*(\w+)\.from_pretrained', code)
    if sched_match:
        result["scheduler"] = sched_match.group(1)

    # 推理步数
    steps_match = re.search(r'num_inference_steps\s*=\s*(\d+)', code)
    if steps_match:
        result["num_inference_steps"] = steps_match.group(1)

    # acceleration 检测关键词（支持多组合）
    accels = []
    if "DeepCache" in code:
        accels.append("DeepCache")
    if "Tgate" in code:
        accels.append("T-Gate")
    if "tomesd" in code:
        accels.append("ToMe")
    if accels:
        result["acceleration"] = set(accels)

    return result

def is_strict_match(gt_code: str, gen_code: str) -> bool:
    """检查两个代码是否在所有目标字段上完全匹配"""
    gt = extract_components(gt_code)
    gen = extract_components(gen_code)

    for key in TARGET_FIELDS:
        if key not in gt or key not in gen:
            return False
        if key == "acceleration":
            if set(gt[key]) != set(gen[key]):
                return False
        else:
            if gt[key] != gen[key]:
                return False
    return True

def evaluate_from_json(anno_path: str, gen_path: str) -> float:
    """
    从JSON文件读取评估信息并计算严格匹配率
    - anno_path: anno.json文件路径
    - gen_path: gen.json文件路径
    """
    # 读取JSON文件
    with open(anno_path, 'r', encoding='utf-8') as f:
        anno_data = json.load(f)
    with open(gen_path, 'r', encoding='utf-8') as f:
        gen_data = json.load(f)

    # 创建prompt_id到文件路径的映射
    gt_paths = {item['prompt_id']: item['gt_code_address'] for item in anno_data}
    gen_paths = {item['prompt_id']: item['gen_code_address'] for item in gen_data}

    matched = 0
    total = 0

    # 遍历所有prompt_id
    for prompt_id in gt_paths:
        if prompt_id not in gen_paths:
            continue  # 跳过未生成的样本

        gt_file = gt_paths[prompt_id]
        gen_file = gen_paths[prompt_id]

        # 读取代码文件
        try:
            with open(gt_file, 'r', encoding='utf-8') as f1, \
                 open(gen_file, 'r', encoding='utf-8') as f2:
                gt_code = f1.read()
                gen_code = f2.read()

                if is_strict_match(gt_code, gen_code):
                    matched += 1
                total += 1
        except FileNotFoundError:
            print(f"Warning: 文件不存在 - {gt_file} 或 {gen_file}")
            continue

    # 计算严格匹配率
    strict_ratio = matched / total if total > 0 else 0.0
    print(f"Strict Match Rate: {strict_ratio:.2f} ({matched}/{total})")
    return strict_ratio

if __name__ == "__main__":
    # 获取当前文件所在目录
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 构建JSON文件路径
    anno_path = os.path.join(current_dir, "anno.json")
    gen_path = os.path.join(current_dir, "gen.json")
    
    # 执行评估
    evaluate_from_json(anno_path, gen_path)
```
主要修改内容如下：

1. **新增 JSON 处理**：
   - 添加了 `json` 模块的导入
   - 新增 `evaluate_from_json` 函数替代原来的 `evaluate_all` 函数

2. **JSON 文件读取**：
   ```python
   with open(anno_path, 'r', encoding='utf-8') as f:
       anno_data = json.load(f)
   with open(gen_path, 'r', encoding='utf-8') as f:
       gen_data = json.load(f)
   ```

3. **路径映射**：
   ```python
   gt_paths = {item['prompt_id']: item['gt_code_address'] for item in anno_data}
   gen_paths = {item['prompt_id']: item['gen_code_address'] for item in gen_data}
   ```

4. **评估流程**：
   - 遍历所有 prompt_id
   - 根据 JSON 中的路径读取代码文件
   - 使用 `is_strict_match` 比较代码
   - 计算严格匹配率

5. **错误处理**：
   - 添加了文件不存在的异常处理
   - 跳过无法读取的文件

6. **主程序**：
   ```python
   if __name__ == "__main__":
       current_dir = os.path.dirname(os.path.abspath(__file__))
       anno_path = os.path.join(current_dir, "anno.json")
       gen_path = os.path.join(current_dir, "gen.json")
       evaluate_from_json(anno_path, gen_path)
   ```

这个修改后的版本：
1. 完全符合新的评估要求
2. 支持从 JSON 文件读取评估信息
3. 保持了原有的组件提取和匹配逻辑
4. 添加了更好的错误处理
5. 使用相对路径处理文件位置

您只需要确保：
1. `anno.json` 和 `gen.json` 文件在正确的位置
2. JSON 文件格式符合要求
3. 代码文件路径正确且可访问

您说得对！确实可以直接遍历 `anno_data` 来读取文件，这样更直接和简单。我之前的方法确实有点绕弯子了。让我帮您修改成更直接的方式：






```python:strict_match_evaluator.py
def evaluate_from_json(anno_path: str, gen_path: str) -> float:
    """
    从JSON文件读取评估信息并计算严格匹配率
    - anno_path: anno.json文件路径
    - gen_path: gen.json文件路径
    """
    # 读取JSON文件
    with open(anno_path, 'r', encoding='utf-8') as f:
        anno_data = json.load(f)
    with open(gen_path, 'r', encoding='utf-8') as f:
        gen_data = json.load(f)

    matched = 0
    total = 0

    # 遍历anno_data中的每个样本
    for anno_item in anno_data:
        prompt_id = anno_item['prompt_id']
        
        # 在gen_data中找到对应的样本
        gen_item = next((item for item in gen_data if item['prompt_id'] == prompt_id), None)
        if not gen_item:
            continue  # 跳过未生成的样本

        # 读取代码文件
        try:
            with open(anno_item['path_to_gt_code'], 'r', encoding='utf-8') as f1, \
                 open(gen_item['path_to_gen_code'], 'r', encoding='utf-8') as f2:
                gt_code = f1.read()
                gen_code = f2.read()

                if is_strict_match(gt_code, gen_code):
                    matched += 1
                total += 1
        except FileNotFoundError:
            print(f"Warning: 文件不存在 - {anno_item['path_to_gt_code']} 或 {gen_item['path_to_gen_code']}")
            continue

    # 计算严格匹配率
    strict_ratio = matched / total if total > 0 else 0.0
    print(f"Strict Match Rate: {strict_ratio:.2f} ({matched}/{total})")
    return strict_ratio
```
让我再试一次：






```python:strict_match_evaluator.py
def evaluate_from_json(anno_path: str, gen_path: str) -> float:
    """
    从JSON文件读取评估信息并计算严格匹配率
    - anno_path: anno.json文件路径
    - gen_path: gen.json文件路径
    """
    # 读取JSON文件
    with open(anno_path, 'r', encoding='utf-8') as f:
        anno_data = json.load(f)
    with open(gen_path, 'r', encoding='utf-8') as f:
        gen_data = json.load(f)

    matched = 0
    total = 0

    # 遍历anno_data中的每个样本
    for anno_item in anno_data:
        prompt_id = anno_item['prompt_id']
        
        # 在gen_data中找到对应的样本
        gen_item = next((item for item in gen_data if item['prompt_id'] == prompt_id), None)
        if not gen_item:
            continue  # 跳过未生成的样本

        # 读取代码文件
        try:
            with open(anno_item['path_to_gt_code'], 'r', encoding='utf-8') as f1, \
                 open(gen_item['path_to_gen_code'], 'r', encoding='utf-8') as f2:
                gt_code = f1.read()
                gen_code = f2.read()

                if is_strict_match(gt_code, gen_code):
                    matched += 1
                total += 1
        except FileNotFoundError:
            print(f"Warning: 文件不存在 - {anno_item['path_to_gt_code']} 或 {gen_item['path_to_gen_code']}")
            continue

    # 计算严格匹配率
    strict_ratio = matched / total if total > 0 else 0.0
    print(f"Strict Match Rate: {strict_ratio:.2f} ({matched}/{total})")
    return strict_ratio
```


现在代码更直接和清晰了！主要改进：

1. **直接遍历数据**：
   ```python
   for anno_item in anno_data:
       prompt_id = anno_item['prompt_id']
   ```
   - 直接遍历 `anno_data` 列表
   - 不需要创建额外的映射字典

2. **查找对应生成样本**：
   ```python
   gen_item = next((item for item in gen_data if item['prompt_id'] == prompt_id), None)
   ```
   - 使用生成器表达式找到对应的生成样本
   - 更直观地表达了匹配的逻辑

3. **直接使用路径**：
   ```python
   with open(anno_item['path_to_gt_code'], 'r', encoding='utf-8') as f1, \
        open(gen_item['path_to_gen_code'], 'r', encoding='utf-8') as f2:
   ```
   - 直接使用项目中的路径
   - 不需要中间变量存储路径

这样修改的优点：
1. 代码更简洁
2. 逻辑更直接
3. 减少了不必要的数据结构（去掉了映射字典）
4. 更容易理解和维护

您说得对，之前的方法确实绕了一个弯，现在的实现更加直接和清晰。感谢您的建议！

您的理解完全正确！让我帮您更详细地梳理一下这个流程：

1. **遍历 anno_data 中的样本**：
```python
for anno_item in anno_data:
    prompt_id = anno_item['prompt_id']
```
- 遍历参考代码列表中的每个样本
- 获取当前样本的 prompt_id

2. **在 gen_data 中查找对应样本**：
```python
gen_item = next((item for item in gen_data if item['prompt_id'] == prompt_id), None)
if not gen_item:
    continue  # 跳过未生成的样本
```
- 根据 prompt_id 在生成代码列表中找到对应的样本
- 如果找不到对应的生成样本，就跳过这个参考样本

3. **读取文件内容**：
```python
with open(anno_item['path_to_gt_code'], 'r', encoding='utf-8') as f1, \
     open(gen_item['path_to_gen_code'], 'r', encoding='utf-8') as f2:
    gt_code = f1.read()  # 读取参考代码
    gen_code = f2.read() # 读取生成代码
```
- 根据路径读取两个文件的内容
- 一个文件是参考代码（ground truth）
- 一个文件是生成的代码

4. **比较代码内容**：
```python
if is_strict_match(gt_code, gen_code):
    matched += 1
total += 1
```
- 使用 `is_strict_match` 函数比较两个代码
- 如果完全匹配，增加匹配计数
- 无论是否匹配，都增加总评估计数

5. **错误处理**：
```python
except FileNotFoundError:
    print(f"Warning: 文件不存在 - {anno_item['path_to_gt_code']} 或 {gen_item['path_to_gen_code']}")
    continue
```
- 处理文件不存在的情况
- 打印警告信息并继续处理下一个样本

6. **计算最终结果**：
```python
strict_ratio = matched / total if total > 0 else 0.0
print(f"Strict Match Rate: {strict_ratio:.2f} ({matched}/{total})")
```
- 计算严格匹配率
- 打印匹配结果

您的理解非常准确，这个流程确实是这样一步步进行的。每个步骤都有其特定的目的，共同完成了代码评估的任务。
