我已经添加了详细的评估报告功能。这个改进后的版本会生成一个名为match_report.json的报告文件，包含以下信息：
总体汇总信息：
严格匹配率
匹配成功数量
总样本数量
缺失样本数量
不匹配样本数量
匹配成功的项目：
每个成功匹配的样本ID
原始代码和生成代码的路径
每个字段的详细比较结果
匹配失败的项目：
每个不匹配的样本ID
原始代码和生成代码的路径
不匹配的具体字段列表
每个字段的详细比较结果（包括原值和生成值）
缺失项目：
缺失的样本ID
缺失原因（文件不存在或生成数据中未找到）
这个报告格式帮助研究人员深入了解匹配失败的原因，通过比较每个字段的具体差异，可以分析生成代码与目标代码在功能上的差距。
匹配分析非常详细，对每个字段会显示：
匹配状态（匹配、不匹配、缺失等）
原始代码中的值
生成代码中的值
这种格式对于调试和改进生成模型非常有帮助


```python:generate_10_gen.py
import json
import os

def generate_10_gen():
    # 检查输入文件是否存在
    if not os.path.exists('gen.json'):
        print("错误: gen.json 文件不存在")
        return
    
    # 读取gen.json文件
    try:
        with open('gen.json', 'r', encoding='utf-8') as f:
            gen_data = json.load(f)
            print(f"成功读取gen.json文件，包含{len(gen_data)}条记录")
    except Exception as e:
        print(f"读取gen.json文件失败: {e}")
        return
    
    # 只保留前10个记录
    gen_data_10 = gen_data[:10]
    print(f"已提取前10条记录")
    
    # 更新path_to_gen_code字段
    for item in gen_data_10:
        prompt_id = item['prompt_id']
        item['path_to_gen_code'] = f"gen_code/{prompt_id}.py"
        print(f"已更新记录ID {prompt_id} 的path_to_gen_code字段")
    
    # 保存为gen_10.json
    try:
        with open('gen_10.json', 'w', encoding='utf-8') as f:
            json.dump(gen_data_10, f, indent=2, ensure_ascii=False)
        print(f"成功保存gen_10.json文件")
    except Exception as e:
        print(f"保存gen_10.json文件失败: {e}")
        return
    
    print(f"处理完成，已生成gen_10.json文件，包含{len(gen_data_10)}条记录")

if __name__ == "__main__":
    generate_10_gen()
```
已创建脚本来完成您需要的功能。这个脚本会：

1. 从`gen.json`读取所有记录
2. 选取前10条记录
3. 更新每条记录的`path_to_gen_code`字段为`gen_code/{prompt_id}.py`格式
4. 将结果保存到`gen_10.json`文件

脚本包含了完整的错误处理和日志输出，方便您了解执行过程。运行这个脚本后，您就能得到需要的`gen_10.json`文件了。

您的`strict_match_evaluator.py`文件中匹配了五个关键元素，我来总结一下各个匹配逻辑：

### 1. Pipeline 名称
```python
pipe_match = re.search(r'(\w+Pipeline)\.from_\w+', code)
```
- 匹配模式：`xxxPipeline.from_xxx`
- 例如：`StableDiffusionPipeline.from_pretrained` 会提取出 `StableDiffusionPipeline`
- 您的理解完全正确

### 2. Model ID
```python
model_match = re.search(r'model_id\s*=\s*["\']([^"\']+)["\']', code)
if not model_match:
    model_match = re.search(r'\.from_pretrained\(\s*["\']([^"\']+)["\']', code)
```
- 匹配模式一：`model_id = "xxx"` 或 `model_id='xxx'`
- 匹配模式二：`.from_pretrained("xxx")` 第一个字符串参数
- 例如：`"runwayml/stable-diffusion-v1-5"` 或 `model_id="runwayml/stable-diffusion-v1-5"`

### 3. Scheduler 类型
```python
sched_match = re.search(r'scheduler\s*=\s*(\w+)\.from_\w+', code)
```
- 匹配模式：`scheduler = XXX.from_xxx`
- 例如：`scheduler = DPMSolverMultistepScheduler.from_config` 会提取出 `DPMSolverMultistepScheduler`

### 4. 推理步数
```python
steps_match = re.search(r'num_inference_steps\s*=\s*(\d+)', code)
```
- 匹配模式：`num_inference_steps = 数字`
- 例如：`num_inference_steps=20` 会提取出 `20`

### 5. 加速方法 (Acceleration)
```python
accels = []
if "DeepCache" in code:
    accels.append("DeepCache")
if "Tgate" in code:
    accels.append("T-Gate")
if "tomesd" in code:
    accels.append("ToMe")
```
- 匹配模式：直接在代码中搜索特定关键词
- 是否包含 `DeepCache`、`Tgate` 或 `tomesd` 这些字符串
- 这个匹配逻辑不用正则表达式，直接使用字符串包含判断
- 支持多种加速方法同时存在

每种匹配逻辑都针对 Stable Diffusion 代码中的特定模式进行了定制，目的是提取出这五个关键元素，然后通过比较这些元素来判断两份代码是否在功能上是匹配的。
我来简化一下方案，只处理两种情况：

```python:strict_match_evaluator.py
    # model id - 同时匹配两种情况
    model_match = re.search(r'model_id\s*=\s*["\']([^"\']+)["\']', code)
    if not model_match:
        # 如果没找到model_id参数，尝试匹配from_pretrained的第一个参数
        model_match = re.search(r'\.from_pretrained\(\s*["\']([^"\']+)["\']', code)
    if model_match:
        result["model_id"] = model_match.group(1)
```
已经修改好了匹配逻辑，现在可以处理两种常见情况：

1. 第一种情况：匹配 `model_id = "xxx"` 格式，支持单引号和双引号
2. 第二种情况：匹配 `.from_pretrained("xxx")` 格式，获取第一个字符串参数

这个修改的优点：
- 简单易懂，只处理两种最常见的情况
- 支持单引号和双引号（`["\']`）
- 使用嵌套if结构，优先匹配明确的model_id参数
- 可以成功匹配你示例中的情况：
  ```python
  pipe = StableDiffusionXLPipeline.from_pretrained(
      "stabilityai/stable-diffusion-xl-base-1.0",
      safety_checker=None,
      cache_dir="./cache_model"
  )
  ```

这个解决方案足够实用，能处理大部分常见的Stable Diffusion代码模式。

你提出了一个很好的问题。确实，`from_pretrained` 的第一个参数通常是模型 ID，但并不总是如此。让我详细分析一下：

在 diffusers 库中，`from_pretrained` 方法的签名通常是：
```python
@classmethod
def from_pretrained(cls, pretrained_model_name_or_path, **kwargs)
```

其中第一个参数 `pretrained_model_name_or_path` 可以是：
1. 模型 ID（如 "stabilityai/stable-diffusion-xl-base-1.0"）
2. 本地路径（如 "./my_model"）
3. URL 路径

所以你担心的是合理的，简单匹配 `from_pretrained` 后的第一个字符串可能会有误判。

更合适的方案：

1. **使用多种匹配模式并优先级排序**：
```python
# 尝试从明确的命名参数匹配
model_match = re.search(r'pretrained_model_name_or_path\s*=\s*["\']([^"\']+)["\']', code)
if not model_match:
    # 尝试匹配 model_id 参数
    model_match = re.search(r'model_id\s*=\s*["\']([^"\']+)["\']', code)
if not model_match:
    # 尝试匹配 from_pretrained 的第一个位置参数，但排除明显是本地路径的情况
    model_match = re.search(r'\.from_pretrained\(\s*["\']([^"\'./\\]+(?:/[^"\']+)?)["\']', code)
    
if model_match:
    result["model_id"] = model_match.group(1)
```

2. **使用启发式方法**：
如果字符串包含 "/" 且不以 "./" 或 "/" 开头，很可能是模型 ID。

```python
import os

def extract_model_id(code):
    # 尝试多种模式匹配
    patterns = [
        r'pretrained_model_name_or_path\s*=\s*["\']([^"\']+)["\']',  # 命名参数
        r'model_id\s*=\s*["\']([^"\']+)["\']',                       # model_id 参数 
        r'\.from_pretrained\(\s*["\']([^"\']+)["\']'                 # 位置参数
    ]
    
    for pattern in patterns:
        match = re.search(pattern, code)
        if match:
            potential_id = match.group(1)
            # 启发式判断：如果包含"/"且不是本地路径，很可能是模型ID
            if "/" in potential_id and not (potential_id.startswith("./") or potential_id.startswith("/") or os.path.exists(potential_id)):
                return potential_id
            # 如果匹配到 model_id 或 pretrained_model_name_or_path 参数，直接返回
            if "model_id" in pattern or "pretrained_model_name_or_path" in pattern:
                return potential_id
    
    return None
```

这种方法更加稳健，能够处理大多数情况，但仍有可能出错。对于完全精确的分析，可能需要使用AST解析。不过对于大多数常见用例，上述方法已经足够了。
你的问题是需要提取 `from_pretrained()` 方法中的模型 ID，目前的正则表达式只匹配 `model_id = "..."` 形式。

以下是一个更通用的正则表达式，可以同时匹配这两种情况：

```python
# 先尝试匹配 from_pretrained 第一个参数形式
model_match = re.search(r'\.from_pretrained\(\s*["\']([^"\']+)["\']', code)
if model_match:
    result["model_id"] = model_match.group(1)
else:
    # 如果没找到，再尝试匹配 model_id 参数形式
    model_match = re.search(r'model_id\s*=\s*["\']([^"\']+)["\']', code)
    if model_match:
        result["model_id"] = model_match.group(1)
```

这个正则表达式的特点：

1. 首先查找 `.from_pretrained(` 后面跟着引号包裹的字符串
2. `["\']([^"\']+)["\']` 可以匹配单引号或双引号包裹的内容
3. 如果第一种匹配失败，再尝试匹配 `model_id = "..."` 形式
4. 能够处理引号之间有空格的情况

如果你想用一个更简洁的正则表达式来匹配两种情况，可以尝试：

```python
model_match = re.search(r'(?:\.from_pretrained\(\s*|model_id\s*=\s*)["\']([^"\']+)["\']', code)
if model_match:
    result["model_id"] = model_match.group(1)
```

这里使用了 `(?:...)` 非捕获组来匹配两种可能的前缀，然后捕获引号中的模型 ID。

如果你想匹配形如 `xxxPipeline.from_pretrained` 的模式并提取 `xxxPipeline` 作为 pipeline 名字，可以使用以下正则表达式：

```python
pipe_match = re.search(r'(\w+Pipeline)\.from_pretrained', code)
if pipe_match:
    result["pipeline"] = pipe_match.group(1)
```

这种匹配方式的优点：
1. 直接匹配代码中实际使用的 pipeline 类名
2. 不依赖于 import 语句
3. 更准确地捕获实际调用的 pipeline

如果你想匹配更通用的情况（比如 `.from_config` 等方法），可以这样写：

```python
pipe_match = re.search(r'(\w+Pipeline)\.from_\w+', code)
if pipe_match:
    result["pipeline"] = pipe_match.group(1)
```

这样不管是 `StableDiffusionPipeline.from_pretrained` 还是 `StableDiffusionXLPipeline.from_config` 都能被正确匹配，更适合你的需求。

如果你想同时保留原来的匹配方式作为备选，可以这样写：

```python
# 尝试从使用中匹配
pipe_match = re.search(r'(\w+Pipeline)\.from_\w+', code)
if pipe_match:
    result["pipeline"] = pipe_match.group(1)
else:
    # 如果没找到，尝试从 import 语句匹配
    pipe_match = re.search(r'from diffusers import ([\w, ]+)', code)
    if pipe_match:
        pipe_classes = [x.strip() for x in pipe_match.group(1).split(",")]
        for pipe in pipe_classes:
            if "Pipeline" in pipe:
                result["pipeline"] = pipe
                break
```
你提供的正则表达式有语法错误和逻辑问题：

```python
sched_match = re.search(r'scheduler\s*=\s*(\w+)\.from_, code)
```

1. 字符串没有正确闭合 - 在`from_`后缺少结束引号`'`
2. 模式不完整 - `\.from_`后面没有完整匹配

更好的写法应该是：

```python
sched_match = re.search(r'scheduler\s*=\s*(\w+)\.from_\w+', code)
```

这样修改后：
- `from_\w+` 会匹配以`from_`开头，后面跟任意字母、数字或下划线的方法名
- 能够同时匹配`from_pretrained`、`from_config`等多种情况
- 保留了捕获组`(\w+)`来获取调度器类型名称

如果你想更精确地只匹配特定几种方法，可以使用选择模式：

```python
sched_match = re.search(r'scheduler\s*=\s*(\w+)\.(from_pretrained|from_config)', code)
```

这样既能保持通用性又确保只匹配你关心的方法。
我来解释这行正则表达式代码的作用：

```python
sched_match = re.search(r'scheduler\s*=\s*(\w+)\.from_pretrained', code)
```

这行代码的含义：

1. 这是一个正则表达式匹配，用于在`code`变量中查找特定模式的文本
2. 它试图匹配形如`scheduler = XXX.from_pretrained`的代码片段
3. 详细解释：
   - `scheduler` - 匹配字面文本"scheduler"
   - `\s*` - 匹配0个或多个空白字符（空格、制表符等）
   - `=` - 匹配等号
   - `\s*` - 再次匹配0个或多个空白字符
   - `(\w+)` - 这是一个捕获组，匹配1个或多个字母、数字或下划线字符，这里捕获的是调度器的类型名称
   - `\.` - 匹配点号（`.`需要转义）
   - `from_pretrained` - 匹配字面文本"from_pretrained"

对于你提供的代码：
```python
scheduler = DDIMScheduler.from_config(pipe.scheduler.config)
```

这行代码**不会**被上述正则表达式匹配到，因为：
1. 正则表达式specifically寻找`.from_pretrained`方法
2. 而你的代码使用的是`.from_config`方法

如果你想修改正则表达式来匹配你的代码，可以这样做：

```python
sched_match = re.search(r'scheduler\s*=\s*(\w+)\.from_config', code)
```

或者如果你想同时匹配两种情况：

```python
sched_match = re.search(r'scheduler\s*=\s*(\w+)\.(from_pretrained|from_config)', code)
```

这样就能捕获到`DDIMScheduler`这个调度器类型名称了。
可能有几个原因导致代码在Linux服务器上没有显示结果：

1. 文件权限问题：Linux对文件权限管理更严格，代码可能没有足够权限读取或修改文件

2. 文件路径问题：Windows和Linux的路径分隔符不同（Windows用反斜杠\，Linux用正斜杠/）

3. 文件编码问题：`utf-8`编码在不同系统上可能有细微差异

4. 打印输出重定向：在VS Code中，输出可能被重定向到其他地方

让我们使用以下方法来排查问题：

```python:generate_complete_gt.py
import json
import os
import shutil
import sys
import platform

def rename_files_and_update_json():
    # 显示当前工作目录
    current_dir = os.getcwd()
    print(f"当前工作目录: {current_dir}")
    
    # 检查anno.json文件是否存在
    if not os.path.exists('anno.json'):
        print("错误: anno.json文件不存在")
        return
        
    # 检查gt_code目录是否存在
    if not os.path.exists('gt_code'):
        print("错误: gt_code目录不存在")
        return
    
    # 读取anno.json文件
    try:
        with open('anno.json', 'r', encoding='utf-8') as f:
            anno_data = json.load(f)
            print(f"成功读取anno.json文件，包含{len(anno_data)}条记录")
    except Exception as e:
        print(f"读取anno.json文件失败: {e}")
        return
    
    # 获取gt_code文件夹中的所有文件名
    try:
        gt_code_files = os.listdir('gt_code')
        print(f"成功读取gt_code文件夹，包含{len(gt_code_files)}个文件")
    except Exception as e:
        print(f"读取gt_code文件夹失败: {e}")
        return
    
    # 创建文件名与完整路径的映射
    file_path_map = {filename: os.path.join('gt_code', filename) for filename in gt_code_files}
    
    # 清理文件名（移除.py后缀）获取原始文件名到文件的映射
    original_name_map = {os.path.splitext(filename)[0]: filename for filename in gt_code_files}
    
    # 统计匹配情况
    total_prompts = len(anno_data)
    matched = 0
    unmatched = 0
    
    # 对每个prompt_context检查是否有匹配的文件名，有则重命名并更新path_to_gt_code
    for item in anno_data:
        prompt_id = item['prompt_id']
        prompt_context = item['prompt_context']
        
        if prompt_context in original_name_map:
            # 获取原始文件的完整文件名和路径
            original_filename = original_name_map[prompt_context]
            original_path = file_path_map[original_filename]
            
            # 获取文件扩展名
            _, ext = os.path.splitext(original_filename)
            
            # 构造新的文件名和路径
            new_filename = f"{prompt_id}{ext}"
            new_path = os.path.join('gt_code', new_filename)
            
            # 重命名文件
            try:
                print(f"尝试重命名: {original_path} -> {new_path}")
                os.rename(original_path, new_path)
                
                # 更新anno.json中的path_to_gt_code字段
                item['path_to_gt_code'] = f"gt_code/{new_filename}"
                matched += 1
                
                print(f"已重命名: {original_filename} -> {new_filename}")
            except Exception as e:
                print(f"重命名文件失败: {original_filename} -> {new_filename}, 错误: {e}")
        else:
            unmatched += 1
            print(f"未找到匹配: {prompt_context}")
    
    # 保存更新后的anno.json
    try:
        with open('anno.json', 'w', encoding='utf-8') as f:
            json.dump(anno_data, f, indent=2, ensure_ascii=False)
        print(f"anno.json已更新")
    except Exception as e:
        print(f"保存anno.json失败: {e}")
    
    # 打印统计结果
    print(f"\n总prompt数量: {total_prompts}")
    print(f"匹配并重命名数量: {matched}")
    print(f"未匹配数量: {unmatched}")
    print(f"匹配率: {matched/total_prompts*100:.2f}%")

if __name__ == "__main__":
    # 显示系统信息
    print(f"系统: {platform.system()}, 版本: {platform.version()}")
    print(f"Python版本: {sys.version}")
    print("-" * 50)
    
    # 创建备份，以防出现问题
    try:
        shutil.copy('anno.json', 'anno.json.bak')
        print("已创建anno.json备份文件: anno.json.bak")
    except Exception as e:
        print(f"创建备份文件失败: {e}")
        choice = input("是否继续执行程序? (y/n): ")
        if choice.lower() != 'y':
            print("程序已取消")
            exit()
    
    rename_files_and_update_json()
    
    # 确保所有输出都被刷新
    sys.stdout.flush()
    print("程序执行完毕")
```
我已经修改了代码，增加了更多的调试信息和错误检查。这个改进后的版本会：

1. 显示系统和Python版本信息
2. 检查必要文件和目录是否存在
3. 打印更详细的操作步骤和错误信息
4. 确保所有输出被刷新到控制台

在Linux服务器上重新运行这个脚本，应该能帮助你找出问题所在。可能的原因包括：

1. 工作目录不正确（新版本会显示当前工作目录）
2. 文件或目录不存在或路径问题（新版本会检查文件/目录存在性）
3. 权限问题（会在详细的错误信息中显示）
4. 输出缓冲问题（新增了`sys.stdout.flush()`确保输出显示）

如果运行后仍然没有输出，请检查：
- VS Code的输出终端设置
- 是否有权限在服务器上执行Python脚本
- 服务器上Python的安装情况




